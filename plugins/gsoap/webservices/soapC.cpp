/* soapC.cpp
   Generated by gSOAP 2.8.4 from ./ctrl-webservice-definition.h

Copyright(C) 2000-2011, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
1) GPL or 2) Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.4 2014-02-10 19:38:25 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_switcher__get_signal_description_by_class:
		return soap_in_switcher__get_signal_description_by_class(soap, NULL, NULL, "switcher:get-signal-description-by-class");
	case SOAP_TYPE_switcher__get_signal_description_by_classResponse:
		return soap_in_switcher__get_signal_description_by_classResponse(soap, NULL, NULL, "switcher:get-signal-description-by-classResponse");
	case SOAP_TYPE_switcher__run:
		return soap_in_switcher__run(soap, NULL, NULL, "switcher:run");
	case SOAP_TYPE_switcher__runResponse:
		return soap_in_switcher__runResponse(soap, NULL, NULL, "switcher:runResponse");
	case SOAP_TYPE_switcher__load:
		return soap_in_switcher__load(soap, NULL, NULL, "switcher:load");
	case SOAP_TYPE_switcher__loadResponse:
		return soap_in_switcher__loadResponse(soap, NULL, NULL, "switcher:loadResponse");
	case SOAP_TYPE_switcher__save:
		return soap_in_switcher__save(soap, NULL, NULL, "switcher:save");
	case SOAP_TYPE_switcher__saveResponse:
		return soap_in_switcher__saveResponse(soap, NULL, NULL, "switcher:saveResponse");
	case SOAP_TYPE_switcher__get_signals_description_by_class:
		return soap_in_switcher__get_signals_description_by_class(soap, NULL, NULL, "switcher:get-signals-description-by-class");
	case SOAP_TYPE_switcher__get_signals_description_by_classResponse:
		return soap_in_switcher__get_signals_description_by_classResponse(soap, NULL, NULL, "switcher:get-signals-description-by-classResponse");
	case SOAP_TYPE_switcher__get_signal_description:
		return soap_in_switcher__get_signal_description(soap, NULL, NULL, "switcher:get-signal-description");
	case SOAP_TYPE_switcher__get_signal_descriptionResponse:
		return soap_in_switcher__get_signal_descriptionResponse(soap, NULL, NULL, "switcher:get-signal-descriptionResponse");
	case SOAP_TYPE_switcher__get_signals_description:
		return soap_in_switcher__get_signals_description(soap, NULL, NULL, "switcher:get-signals-description");
	case SOAP_TYPE_switcher__get_signals_descriptionResponse:
		return soap_in_switcher__get_signals_descriptionResponse(soap, NULL, NULL, "switcher:get-signals-descriptionResponse");
	case SOAP_TYPE_switcher__invoke_method:
		return soap_in_switcher__invoke_method(soap, NULL, NULL, "switcher:invoke-method");
	case SOAP_TYPE_switcher__invoke_methodResponse:
		return soap_in_switcher__invoke_methodResponse(soap, NULL, NULL, "switcher:invoke-methodResponse");
	case SOAP_TYPE_switcher__get_method_description_by_class:
		return soap_in_switcher__get_method_description_by_class(soap, NULL, NULL, "switcher:get-method-description-by-class");
	case SOAP_TYPE_switcher__get_method_description_by_classResponse:
		return soap_in_switcher__get_method_description_by_classResponse(soap, NULL, NULL, "switcher:get-method-description-by-classResponse");
	case SOAP_TYPE_switcher__get_methods_description_by_class:
		return soap_in_switcher__get_methods_description_by_class(soap, NULL, NULL, "switcher:get-methods-description-by-class");
	case SOAP_TYPE_switcher__get_methods_description_by_classResponse:
		return soap_in_switcher__get_methods_description_by_classResponse(soap, NULL, NULL, "switcher:get-methods-description-by-classResponse");
	case SOAP_TYPE_switcher__get_method_description:
		return soap_in_switcher__get_method_description(soap, NULL, NULL, "switcher:get-method-description");
	case SOAP_TYPE_switcher__get_method_descriptionResponse:
		return soap_in_switcher__get_method_descriptionResponse(soap, NULL, NULL, "switcher:get-method-descriptionResponse");
	case SOAP_TYPE_switcher__get_methods_description:
		return soap_in_switcher__get_methods_description(soap, NULL, NULL, "switcher:get-methods-description");
	case SOAP_TYPE_switcher__get_methods_descriptionResponse:
		return soap_in_switcher__get_methods_descriptionResponse(soap, NULL, NULL, "switcher:get-methods-descriptionResponse");
	case SOAP_TYPE_switcher__delete_quiddity:
		return soap_in_switcher__delete_quiddity(soap, NULL, NULL, "switcher:delete-quiddity");
	case SOAP_TYPE_switcher__rename_quiddity:
		return soap_in_switcher__rename_quiddity(soap, NULL, NULL, "switcher:rename-quiddity");
	case SOAP_TYPE_switcher__rename_quiddityResponse:
		return soap_in_switcher__rename_quiddityResponse(soap, NULL, NULL, "switcher:rename-quiddityResponse");
	case SOAP_TYPE_switcher__create_named_quiddity:
		return soap_in_switcher__create_named_quiddity(soap, NULL, NULL, "switcher:create-named-quiddity");
	case SOAP_TYPE_switcher__create_named_quiddityResponse:
		return soap_in_switcher__create_named_quiddityResponse(soap, NULL, NULL, "switcher:create-named-quiddityResponse");
	case SOAP_TYPE_switcher__create_quiddity:
		return soap_in_switcher__create_quiddity(soap, NULL, NULL, "switcher:create-quiddity");
	case SOAP_TYPE_switcher__create_quiddityResponse:
		return soap_in_switcher__create_quiddityResponse(soap, NULL, NULL, "switcher:create-quiddityResponse");
	case SOAP_TYPE_switcher__get_property:
		return soap_in_switcher__get_property(soap, NULL, NULL, "switcher:get-property");
	case SOAP_TYPE_switcher__get_propertyResponse:
		return soap_in_switcher__get_propertyResponse(soap, NULL, NULL, "switcher:get-propertyResponse");
	case SOAP_TYPE_switcher__set_property:
		return soap_in_switcher__set_property(soap, NULL, NULL, "switcher:set-property");
	case SOAP_TYPE_switcher__get_property_description_by_class:
		return soap_in_switcher__get_property_description_by_class(soap, NULL, NULL, "switcher:get-property-description-by-class");
	case SOAP_TYPE_switcher__get_property_description_by_classResponse:
		return soap_in_switcher__get_property_description_by_classResponse(soap, NULL, NULL, "switcher:get-property-description-by-classResponse");
	case SOAP_TYPE_switcher__get_properties_description_by_class:
		return soap_in_switcher__get_properties_description_by_class(soap, NULL, NULL, "switcher:get-properties-description-by-class");
	case SOAP_TYPE_switcher__get_properties_description_by_classResponse:
		return soap_in_switcher__get_properties_description_by_classResponse(soap, NULL, NULL, "switcher:get-properties-description-by-classResponse");
	case SOAP_TYPE_switcher__get_property_description:
		return soap_in_switcher__get_property_description(soap, NULL, NULL, "switcher:get-property-description");
	case SOAP_TYPE_switcher__get_property_descriptionResponse:
		return soap_in_switcher__get_property_descriptionResponse(soap, NULL, NULL, "switcher:get-property-descriptionResponse");
	case SOAP_TYPE_switcher__get_properties_description:
		return soap_in_switcher__get_properties_description(soap, NULL, NULL, "switcher:get-properties-description");
	case SOAP_TYPE_switcher__get_properties_descriptionResponse:
		return soap_in_switcher__get_properties_descriptionResponse(soap, NULL, NULL, "switcher:get-properties-descriptionResponse");
	case SOAP_TYPE_switcher__get_quiddity_names:
		return soap_in_switcher__get_quiddity_names(soap, NULL, NULL, "switcher:get-quiddity-names");
	case SOAP_TYPE_switcher__get_quiddity_namesResponse:
		return soap_in_switcher__get_quiddity_namesResponse(soap, NULL, NULL, "switcher:get-quiddity-namesResponse");
	case SOAP_TYPE_switcher__get_class_doc:
		return soap_in_switcher__get_class_doc(soap, NULL, NULL, "switcher:get-class-doc");
	case SOAP_TYPE_switcher__get_class_docResponse:
		return soap_in_switcher__get_class_docResponse(soap, NULL, NULL, "switcher:get-class-docResponse");
	case SOAP_TYPE_switcher__get_quiddities_description:
		return soap_in_switcher__get_quiddities_description(soap, NULL, NULL, "switcher:get-quiddities-description");
	case SOAP_TYPE_switcher__get_quiddities_descriptionResponse:
		return soap_in_switcher__get_quiddities_descriptionResponse(soap, NULL, NULL, "switcher:get-quiddities-descriptionResponse");
	case SOAP_TYPE_switcher__get_quiddity_description:
		return soap_in_switcher__get_quiddity_description(soap, NULL, NULL, "switcher:get-quiddity-description");
	case SOAP_TYPE_switcher__get_quiddity_descriptionResponse:
		return soap_in_switcher__get_quiddity_descriptionResponse(soap, NULL, NULL, "switcher:get-quiddity-descriptionResponse");
	case SOAP_TYPE_switcher__get_classes_doc:
		return soap_in_switcher__get_classes_doc(soap, NULL, NULL, "switcher:get-classes-doc");
	case SOAP_TYPE_switcher__get_classes_docResponse:
		return soap_in_switcher__get_classes_docResponse(soap, NULL, NULL, "switcher:get-classes-docResponse");
	case SOAP_TYPE_switcher__get_factory_capabilities:
		return soap_in_switcher__get_factory_capabilities(soap, NULL, NULL, "switcher:get-factory-capabilities");
	case SOAP_TYPE_switcher__get_factory_capabilitiesResponse:
		return soap_in_switcher__get_factory_capabilitiesResponse(soap, NULL, NULL, "switcher:get-factory-capabilitiesResponse");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:get-signal-description-by-class"))
		{	*type = SOAP_TYPE_switcher__get_signal_description_by_class;
			return soap_in_switcher__get_signal_description_by_class(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:get-signal-description-by-classResponse"))
		{	*type = SOAP_TYPE_switcher__get_signal_description_by_classResponse;
			return soap_in_switcher__get_signal_description_by_classResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:run"))
		{	*type = SOAP_TYPE_switcher__run;
			return soap_in_switcher__run(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:runResponse"))
		{	*type = SOAP_TYPE_switcher__runResponse;
			return soap_in_switcher__runResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:load"))
		{	*type = SOAP_TYPE_switcher__load;
			return soap_in_switcher__load(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:loadResponse"))
		{	*type = SOAP_TYPE_switcher__loadResponse;
			return soap_in_switcher__loadResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:save"))
		{	*type = SOAP_TYPE_switcher__save;
			return soap_in_switcher__save(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:saveResponse"))
		{	*type = SOAP_TYPE_switcher__saveResponse;
			return soap_in_switcher__saveResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:get-signals-description-by-class"))
		{	*type = SOAP_TYPE_switcher__get_signals_description_by_class;
			return soap_in_switcher__get_signals_description_by_class(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:get-signals-description-by-classResponse"))
		{	*type = SOAP_TYPE_switcher__get_signals_description_by_classResponse;
			return soap_in_switcher__get_signals_description_by_classResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:get-signal-description"))
		{	*type = SOAP_TYPE_switcher__get_signal_description;
			return soap_in_switcher__get_signal_description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:get-signal-descriptionResponse"))
		{	*type = SOAP_TYPE_switcher__get_signal_descriptionResponse;
			return soap_in_switcher__get_signal_descriptionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:get-signals-description"))
		{	*type = SOAP_TYPE_switcher__get_signals_description;
			return soap_in_switcher__get_signals_description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:get-signals-descriptionResponse"))
		{	*type = SOAP_TYPE_switcher__get_signals_descriptionResponse;
			return soap_in_switcher__get_signals_descriptionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:invoke-method"))
		{	*type = SOAP_TYPE_switcher__invoke_method;
			return soap_in_switcher__invoke_method(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:invoke-methodResponse"))
		{	*type = SOAP_TYPE_switcher__invoke_methodResponse;
			return soap_in_switcher__invoke_methodResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:get-method-description-by-class"))
		{	*type = SOAP_TYPE_switcher__get_method_description_by_class;
			return soap_in_switcher__get_method_description_by_class(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:get-method-description-by-classResponse"))
		{	*type = SOAP_TYPE_switcher__get_method_description_by_classResponse;
			return soap_in_switcher__get_method_description_by_classResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:get-methods-description-by-class"))
		{	*type = SOAP_TYPE_switcher__get_methods_description_by_class;
			return soap_in_switcher__get_methods_description_by_class(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:get-methods-description-by-classResponse"))
		{	*type = SOAP_TYPE_switcher__get_methods_description_by_classResponse;
			return soap_in_switcher__get_methods_description_by_classResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:get-method-description"))
		{	*type = SOAP_TYPE_switcher__get_method_description;
			return soap_in_switcher__get_method_description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:get-method-descriptionResponse"))
		{	*type = SOAP_TYPE_switcher__get_method_descriptionResponse;
			return soap_in_switcher__get_method_descriptionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:get-methods-description"))
		{	*type = SOAP_TYPE_switcher__get_methods_description;
			return soap_in_switcher__get_methods_description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:get-methods-descriptionResponse"))
		{	*type = SOAP_TYPE_switcher__get_methods_descriptionResponse;
			return soap_in_switcher__get_methods_descriptionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:delete-quiddity"))
		{	*type = SOAP_TYPE_switcher__delete_quiddity;
			return soap_in_switcher__delete_quiddity(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:rename-quiddity"))
		{	*type = SOAP_TYPE_switcher__rename_quiddity;
			return soap_in_switcher__rename_quiddity(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:rename-quiddityResponse"))
		{	*type = SOAP_TYPE_switcher__rename_quiddityResponse;
			return soap_in_switcher__rename_quiddityResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:create-named-quiddity"))
		{	*type = SOAP_TYPE_switcher__create_named_quiddity;
			return soap_in_switcher__create_named_quiddity(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:create-named-quiddityResponse"))
		{	*type = SOAP_TYPE_switcher__create_named_quiddityResponse;
			return soap_in_switcher__create_named_quiddityResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:create-quiddity"))
		{	*type = SOAP_TYPE_switcher__create_quiddity;
			return soap_in_switcher__create_quiddity(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:create-quiddityResponse"))
		{	*type = SOAP_TYPE_switcher__create_quiddityResponse;
			return soap_in_switcher__create_quiddityResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:get-property"))
		{	*type = SOAP_TYPE_switcher__get_property;
			return soap_in_switcher__get_property(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:get-propertyResponse"))
		{	*type = SOAP_TYPE_switcher__get_propertyResponse;
			return soap_in_switcher__get_propertyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:set-property"))
		{	*type = SOAP_TYPE_switcher__set_property;
			return soap_in_switcher__set_property(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:get-property-description-by-class"))
		{	*type = SOAP_TYPE_switcher__get_property_description_by_class;
			return soap_in_switcher__get_property_description_by_class(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:get-property-description-by-classResponse"))
		{	*type = SOAP_TYPE_switcher__get_property_description_by_classResponse;
			return soap_in_switcher__get_property_description_by_classResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:get-properties-description-by-class"))
		{	*type = SOAP_TYPE_switcher__get_properties_description_by_class;
			return soap_in_switcher__get_properties_description_by_class(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:get-properties-description-by-classResponse"))
		{	*type = SOAP_TYPE_switcher__get_properties_description_by_classResponse;
			return soap_in_switcher__get_properties_description_by_classResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:get-property-description"))
		{	*type = SOAP_TYPE_switcher__get_property_description;
			return soap_in_switcher__get_property_description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:get-property-descriptionResponse"))
		{	*type = SOAP_TYPE_switcher__get_property_descriptionResponse;
			return soap_in_switcher__get_property_descriptionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:get-properties-description"))
		{	*type = SOAP_TYPE_switcher__get_properties_description;
			return soap_in_switcher__get_properties_description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:get-properties-descriptionResponse"))
		{	*type = SOAP_TYPE_switcher__get_properties_descriptionResponse;
			return soap_in_switcher__get_properties_descriptionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:get-quiddity-names"))
		{	*type = SOAP_TYPE_switcher__get_quiddity_names;
			return soap_in_switcher__get_quiddity_names(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:get-quiddity-namesResponse"))
		{	*type = SOAP_TYPE_switcher__get_quiddity_namesResponse;
			return soap_in_switcher__get_quiddity_namesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:get-class-doc"))
		{	*type = SOAP_TYPE_switcher__get_class_doc;
			return soap_in_switcher__get_class_doc(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:get-class-docResponse"))
		{	*type = SOAP_TYPE_switcher__get_class_docResponse;
			return soap_in_switcher__get_class_docResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:get-quiddities-description"))
		{	*type = SOAP_TYPE_switcher__get_quiddities_description;
			return soap_in_switcher__get_quiddities_description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:get-quiddities-descriptionResponse"))
		{	*type = SOAP_TYPE_switcher__get_quiddities_descriptionResponse;
			return soap_in_switcher__get_quiddities_descriptionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:get-quiddity-description"))
		{	*type = SOAP_TYPE_switcher__get_quiddity_description;
			return soap_in_switcher__get_quiddity_description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:get-quiddity-descriptionResponse"))
		{	*type = SOAP_TYPE_switcher__get_quiddity_descriptionResponse;
			return soap_in_switcher__get_quiddity_descriptionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:get-classes-doc"))
		{	*type = SOAP_TYPE_switcher__get_classes_doc;
			return soap_in_switcher__get_classes_doc(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:get-classes-docResponse"))
		{	*type = SOAP_TYPE_switcher__get_classes_docResponse;
			return soap_in_switcher__get_classes_docResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:get-factory-capabilities"))
		{	*type = SOAP_TYPE_switcher__get_factory_capabilities;
			return soap_in_switcher__get_factory_capabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "switcher:get-factory-capabilitiesResponse"))
		{	*type = SOAP_TYPE_switcher__get_factory_capabilitiesResponse;
			return soap_in_switcher__get_factory_capabilitiesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_switcher__get_signal_description_by_class:
		return soap_out_switcher__get_signal_description_by_class(soap, tag, id, (const struct switcher__get_signal_description_by_class *)ptr, "switcher:get-signal-description-by-class");
	case SOAP_TYPE_switcher__get_signal_description_by_classResponse:
		return soap_out_switcher__get_signal_description_by_classResponse(soap, tag, id, (const struct switcher__get_signal_description_by_classResponse *)ptr, "switcher:get-signal-description-by-classResponse");
	case SOAP_TYPE_switcher__run:
		return soap_out_switcher__run(soap, tag, id, (const struct switcher__run *)ptr, "switcher:run");
	case SOAP_TYPE_switcher__runResponse:
		return soap_out_switcher__runResponse(soap, tag, id, (const struct switcher__runResponse *)ptr, "switcher:runResponse");
	case SOAP_TYPE_switcher__load:
		return soap_out_switcher__load(soap, tag, id, (const struct switcher__load *)ptr, "switcher:load");
	case SOAP_TYPE_switcher__loadResponse:
		return soap_out_switcher__loadResponse(soap, tag, id, (const struct switcher__loadResponse *)ptr, "switcher:loadResponse");
	case SOAP_TYPE_switcher__save:
		return soap_out_switcher__save(soap, tag, id, (const struct switcher__save *)ptr, "switcher:save");
	case SOAP_TYPE_switcher__saveResponse:
		return soap_out_switcher__saveResponse(soap, tag, id, (const struct switcher__saveResponse *)ptr, "switcher:saveResponse");
	case SOAP_TYPE_switcher__get_signals_description_by_class:
		return soap_out_switcher__get_signals_description_by_class(soap, tag, id, (const struct switcher__get_signals_description_by_class *)ptr, "switcher:get-signals-description-by-class");
	case SOAP_TYPE_switcher__get_signals_description_by_classResponse:
		return soap_out_switcher__get_signals_description_by_classResponse(soap, tag, id, (const struct switcher__get_signals_description_by_classResponse *)ptr, "switcher:get-signals-description-by-classResponse");
	case SOAP_TYPE_switcher__get_signal_description:
		return soap_out_switcher__get_signal_description(soap, tag, id, (const struct switcher__get_signal_description *)ptr, "switcher:get-signal-description");
	case SOAP_TYPE_switcher__get_signal_descriptionResponse:
		return soap_out_switcher__get_signal_descriptionResponse(soap, tag, id, (const struct switcher__get_signal_descriptionResponse *)ptr, "switcher:get-signal-descriptionResponse");
	case SOAP_TYPE_switcher__get_signals_description:
		return soap_out_switcher__get_signals_description(soap, tag, id, (const struct switcher__get_signals_description *)ptr, "switcher:get-signals-description");
	case SOAP_TYPE_switcher__get_signals_descriptionResponse:
		return soap_out_switcher__get_signals_descriptionResponse(soap, tag, id, (const struct switcher__get_signals_descriptionResponse *)ptr, "switcher:get-signals-descriptionResponse");
	case SOAP_TYPE_switcher__invoke_method:
		return soap_out_switcher__invoke_method(soap, tag, id, (const struct switcher__invoke_method *)ptr, "switcher:invoke-method");
	case SOAP_TYPE_switcher__invoke_methodResponse:
		return soap_out_switcher__invoke_methodResponse(soap, tag, id, (const struct switcher__invoke_methodResponse *)ptr, "switcher:invoke-methodResponse");
	case SOAP_TYPE_switcher__get_method_description_by_class:
		return soap_out_switcher__get_method_description_by_class(soap, tag, id, (const struct switcher__get_method_description_by_class *)ptr, "switcher:get-method-description-by-class");
	case SOAP_TYPE_switcher__get_method_description_by_classResponse:
		return soap_out_switcher__get_method_description_by_classResponse(soap, tag, id, (const struct switcher__get_method_description_by_classResponse *)ptr, "switcher:get-method-description-by-classResponse");
	case SOAP_TYPE_switcher__get_methods_description_by_class:
		return soap_out_switcher__get_methods_description_by_class(soap, tag, id, (const struct switcher__get_methods_description_by_class *)ptr, "switcher:get-methods-description-by-class");
	case SOAP_TYPE_switcher__get_methods_description_by_classResponse:
		return soap_out_switcher__get_methods_description_by_classResponse(soap, tag, id, (const struct switcher__get_methods_description_by_classResponse *)ptr, "switcher:get-methods-description-by-classResponse");
	case SOAP_TYPE_switcher__get_method_description:
		return soap_out_switcher__get_method_description(soap, tag, id, (const struct switcher__get_method_description *)ptr, "switcher:get-method-description");
	case SOAP_TYPE_switcher__get_method_descriptionResponse:
		return soap_out_switcher__get_method_descriptionResponse(soap, tag, id, (const struct switcher__get_method_descriptionResponse *)ptr, "switcher:get-method-descriptionResponse");
	case SOAP_TYPE_switcher__get_methods_description:
		return soap_out_switcher__get_methods_description(soap, tag, id, (const struct switcher__get_methods_description *)ptr, "switcher:get-methods-description");
	case SOAP_TYPE_switcher__get_methods_descriptionResponse:
		return soap_out_switcher__get_methods_descriptionResponse(soap, tag, id, (const struct switcher__get_methods_descriptionResponse *)ptr, "switcher:get-methods-descriptionResponse");
	case SOAP_TYPE_switcher__delete_quiddity:
		return soap_out_switcher__delete_quiddity(soap, tag, id, (const struct switcher__delete_quiddity *)ptr, "switcher:delete-quiddity");
	case SOAP_TYPE_switcher__rename_quiddity:
		return soap_out_switcher__rename_quiddity(soap, tag, id, (const struct switcher__rename_quiddity *)ptr, "switcher:rename-quiddity");
	case SOAP_TYPE_switcher__rename_quiddityResponse:
		return soap_out_switcher__rename_quiddityResponse(soap, tag, id, (const struct switcher__rename_quiddityResponse *)ptr, "switcher:rename-quiddityResponse");
	case SOAP_TYPE_switcher__create_named_quiddity:
		return soap_out_switcher__create_named_quiddity(soap, tag, id, (const struct switcher__create_named_quiddity *)ptr, "switcher:create-named-quiddity");
	case SOAP_TYPE_switcher__create_named_quiddityResponse:
		return soap_out_switcher__create_named_quiddityResponse(soap, tag, id, (const struct switcher__create_named_quiddityResponse *)ptr, "switcher:create-named-quiddityResponse");
	case SOAP_TYPE_switcher__create_quiddity:
		return soap_out_switcher__create_quiddity(soap, tag, id, (const struct switcher__create_quiddity *)ptr, "switcher:create-quiddity");
	case SOAP_TYPE_switcher__create_quiddityResponse:
		return soap_out_switcher__create_quiddityResponse(soap, tag, id, (const struct switcher__create_quiddityResponse *)ptr, "switcher:create-quiddityResponse");
	case SOAP_TYPE_switcher__get_property:
		return soap_out_switcher__get_property(soap, tag, id, (const struct switcher__get_property *)ptr, "switcher:get-property");
	case SOAP_TYPE_switcher__get_propertyResponse:
		return soap_out_switcher__get_propertyResponse(soap, tag, id, (const struct switcher__get_propertyResponse *)ptr, "switcher:get-propertyResponse");
	case SOAP_TYPE_switcher__set_property:
		return soap_out_switcher__set_property(soap, tag, id, (const struct switcher__set_property *)ptr, "switcher:set-property");
	case SOAP_TYPE_switcher__get_property_description_by_class:
		return soap_out_switcher__get_property_description_by_class(soap, tag, id, (const struct switcher__get_property_description_by_class *)ptr, "switcher:get-property-description-by-class");
	case SOAP_TYPE_switcher__get_property_description_by_classResponse:
		return soap_out_switcher__get_property_description_by_classResponse(soap, tag, id, (const struct switcher__get_property_description_by_classResponse *)ptr, "switcher:get-property-description-by-classResponse");
	case SOAP_TYPE_switcher__get_properties_description_by_class:
		return soap_out_switcher__get_properties_description_by_class(soap, tag, id, (const struct switcher__get_properties_description_by_class *)ptr, "switcher:get-properties-description-by-class");
	case SOAP_TYPE_switcher__get_properties_description_by_classResponse:
		return soap_out_switcher__get_properties_description_by_classResponse(soap, tag, id, (const struct switcher__get_properties_description_by_classResponse *)ptr, "switcher:get-properties-description-by-classResponse");
	case SOAP_TYPE_switcher__get_property_description:
		return soap_out_switcher__get_property_description(soap, tag, id, (const struct switcher__get_property_description *)ptr, "switcher:get-property-description");
	case SOAP_TYPE_switcher__get_property_descriptionResponse:
		return soap_out_switcher__get_property_descriptionResponse(soap, tag, id, (const struct switcher__get_property_descriptionResponse *)ptr, "switcher:get-property-descriptionResponse");
	case SOAP_TYPE_switcher__get_properties_description:
		return soap_out_switcher__get_properties_description(soap, tag, id, (const struct switcher__get_properties_description *)ptr, "switcher:get-properties-description");
	case SOAP_TYPE_switcher__get_properties_descriptionResponse:
		return soap_out_switcher__get_properties_descriptionResponse(soap, tag, id, (const struct switcher__get_properties_descriptionResponse *)ptr, "switcher:get-properties-descriptionResponse");
	case SOAP_TYPE_switcher__get_quiddity_names:
		return soap_out_switcher__get_quiddity_names(soap, tag, id, (const struct switcher__get_quiddity_names *)ptr, "switcher:get-quiddity-names");
	case SOAP_TYPE_switcher__get_quiddity_namesResponse:
		return soap_out_switcher__get_quiddity_namesResponse(soap, tag, id, (const struct switcher__get_quiddity_namesResponse *)ptr, "switcher:get-quiddity-namesResponse");
	case SOAP_TYPE_switcher__get_class_doc:
		return soap_out_switcher__get_class_doc(soap, tag, id, (const struct switcher__get_class_doc *)ptr, "switcher:get-class-doc");
	case SOAP_TYPE_switcher__get_class_docResponse:
		return soap_out_switcher__get_class_docResponse(soap, tag, id, (const struct switcher__get_class_docResponse *)ptr, "switcher:get-class-docResponse");
	case SOAP_TYPE_switcher__get_quiddities_description:
		return soap_out_switcher__get_quiddities_description(soap, tag, id, (const struct switcher__get_quiddities_description *)ptr, "switcher:get-quiddities-description");
	case SOAP_TYPE_switcher__get_quiddities_descriptionResponse:
		return soap_out_switcher__get_quiddities_descriptionResponse(soap, tag, id, (const struct switcher__get_quiddities_descriptionResponse *)ptr, "switcher:get-quiddities-descriptionResponse");
	case SOAP_TYPE_switcher__get_quiddity_description:
		return soap_out_switcher__get_quiddity_description(soap, tag, id, (const struct switcher__get_quiddity_description *)ptr, "switcher:get-quiddity-description");
	case SOAP_TYPE_switcher__get_quiddity_descriptionResponse:
		return soap_out_switcher__get_quiddity_descriptionResponse(soap, tag, id, (const struct switcher__get_quiddity_descriptionResponse *)ptr, "switcher:get-quiddity-descriptionResponse");
	case SOAP_TYPE_switcher__get_classes_doc:
		return soap_out_switcher__get_classes_doc(soap, tag, id, (const struct switcher__get_classes_doc *)ptr, "switcher:get-classes-doc");
	case SOAP_TYPE_switcher__get_classes_docResponse:
		return soap_out_switcher__get_classes_docResponse(soap, tag, id, (const struct switcher__get_classes_docResponse *)ptr, "switcher:get-classes-docResponse");
	case SOAP_TYPE_switcher__get_factory_capabilities:
		return soap_out_switcher__get_factory_capabilities(soap, tag, id, (const struct switcher__get_factory_capabilities *)ptr, "switcher:get-factory-capabilities");
	case SOAP_TYPE_switcher__get_factory_capabilitiesResponse:
		return soap_out_switcher__get_factory_capabilitiesResponse(soap, tag, id, (const struct switcher__get_factory_capabilitiesResponse *)ptr, "switcher:get-factory-capabilitiesResponse");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_switcher__get_signal_description_by_class:
		soap_serialize_switcher__get_signal_description_by_class(soap, (const struct switcher__get_signal_description_by_class *)ptr);
		break;
	case SOAP_TYPE_switcher__get_signal_description_by_classResponse:
		soap_serialize_switcher__get_signal_description_by_classResponse(soap, (const struct switcher__get_signal_description_by_classResponse *)ptr);
		break;
	case SOAP_TYPE_switcher__run:
		soap_serialize_switcher__run(soap, (const struct switcher__run *)ptr);
		break;
	case SOAP_TYPE_switcher__runResponse:
		soap_serialize_switcher__runResponse(soap, (const struct switcher__runResponse *)ptr);
		break;
	case SOAP_TYPE_switcher__load:
		soap_serialize_switcher__load(soap, (const struct switcher__load *)ptr);
		break;
	case SOAP_TYPE_switcher__loadResponse:
		soap_serialize_switcher__loadResponse(soap, (const struct switcher__loadResponse *)ptr);
		break;
	case SOAP_TYPE_switcher__save:
		soap_serialize_switcher__save(soap, (const struct switcher__save *)ptr);
		break;
	case SOAP_TYPE_switcher__saveResponse:
		soap_serialize_switcher__saveResponse(soap, (const struct switcher__saveResponse *)ptr);
		break;
	case SOAP_TYPE_switcher__get_signals_description_by_class:
		soap_serialize_switcher__get_signals_description_by_class(soap, (const struct switcher__get_signals_description_by_class *)ptr);
		break;
	case SOAP_TYPE_switcher__get_signals_description_by_classResponse:
		soap_serialize_switcher__get_signals_description_by_classResponse(soap, (const struct switcher__get_signals_description_by_classResponse *)ptr);
		break;
	case SOAP_TYPE_switcher__get_signal_description:
		soap_serialize_switcher__get_signal_description(soap, (const struct switcher__get_signal_description *)ptr);
		break;
	case SOAP_TYPE_switcher__get_signal_descriptionResponse:
		soap_serialize_switcher__get_signal_descriptionResponse(soap, (const struct switcher__get_signal_descriptionResponse *)ptr);
		break;
	case SOAP_TYPE_switcher__get_signals_description:
		soap_serialize_switcher__get_signals_description(soap, (const struct switcher__get_signals_description *)ptr);
		break;
	case SOAP_TYPE_switcher__get_signals_descriptionResponse:
		soap_serialize_switcher__get_signals_descriptionResponse(soap, (const struct switcher__get_signals_descriptionResponse *)ptr);
		break;
	case SOAP_TYPE_switcher__invoke_method:
		soap_serialize_switcher__invoke_method(soap, (const struct switcher__invoke_method *)ptr);
		break;
	case SOAP_TYPE_switcher__invoke_methodResponse:
		soap_serialize_switcher__invoke_methodResponse(soap, (const struct switcher__invoke_methodResponse *)ptr);
		break;
	case SOAP_TYPE_switcher__get_method_description_by_class:
		soap_serialize_switcher__get_method_description_by_class(soap, (const struct switcher__get_method_description_by_class *)ptr);
		break;
	case SOAP_TYPE_switcher__get_method_description_by_classResponse:
		soap_serialize_switcher__get_method_description_by_classResponse(soap, (const struct switcher__get_method_description_by_classResponse *)ptr);
		break;
	case SOAP_TYPE_switcher__get_methods_description_by_class:
		soap_serialize_switcher__get_methods_description_by_class(soap, (const struct switcher__get_methods_description_by_class *)ptr);
		break;
	case SOAP_TYPE_switcher__get_methods_description_by_classResponse:
		soap_serialize_switcher__get_methods_description_by_classResponse(soap, (const struct switcher__get_methods_description_by_classResponse *)ptr);
		break;
	case SOAP_TYPE_switcher__get_method_description:
		soap_serialize_switcher__get_method_description(soap, (const struct switcher__get_method_description *)ptr);
		break;
	case SOAP_TYPE_switcher__get_method_descriptionResponse:
		soap_serialize_switcher__get_method_descriptionResponse(soap, (const struct switcher__get_method_descriptionResponse *)ptr);
		break;
	case SOAP_TYPE_switcher__get_methods_description:
		soap_serialize_switcher__get_methods_description(soap, (const struct switcher__get_methods_description *)ptr);
		break;
	case SOAP_TYPE_switcher__get_methods_descriptionResponse:
		soap_serialize_switcher__get_methods_descriptionResponse(soap, (const struct switcher__get_methods_descriptionResponse *)ptr);
		break;
	case SOAP_TYPE_switcher__delete_quiddity:
		soap_serialize_switcher__delete_quiddity(soap, (const struct switcher__delete_quiddity *)ptr);
		break;
	case SOAP_TYPE_switcher__rename_quiddity:
		soap_serialize_switcher__rename_quiddity(soap, (const struct switcher__rename_quiddity *)ptr);
		break;
	case SOAP_TYPE_switcher__rename_quiddityResponse:
		soap_serialize_switcher__rename_quiddityResponse(soap, (const struct switcher__rename_quiddityResponse *)ptr);
		break;
	case SOAP_TYPE_switcher__create_named_quiddity:
		soap_serialize_switcher__create_named_quiddity(soap, (const struct switcher__create_named_quiddity *)ptr);
		break;
	case SOAP_TYPE_switcher__create_named_quiddityResponse:
		soap_serialize_switcher__create_named_quiddityResponse(soap, (const struct switcher__create_named_quiddityResponse *)ptr);
		break;
	case SOAP_TYPE_switcher__create_quiddity:
		soap_serialize_switcher__create_quiddity(soap, (const struct switcher__create_quiddity *)ptr);
		break;
	case SOAP_TYPE_switcher__create_quiddityResponse:
		soap_serialize_switcher__create_quiddityResponse(soap, (const struct switcher__create_quiddityResponse *)ptr);
		break;
	case SOAP_TYPE_switcher__get_property:
		soap_serialize_switcher__get_property(soap, (const struct switcher__get_property *)ptr);
		break;
	case SOAP_TYPE_switcher__get_propertyResponse:
		soap_serialize_switcher__get_propertyResponse(soap, (const struct switcher__get_propertyResponse *)ptr);
		break;
	case SOAP_TYPE_switcher__set_property:
		soap_serialize_switcher__set_property(soap, (const struct switcher__set_property *)ptr);
		break;
	case SOAP_TYPE_switcher__get_property_description_by_class:
		soap_serialize_switcher__get_property_description_by_class(soap, (const struct switcher__get_property_description_by_class *)ptr);
		break;
	case SOAP_TYPE_switcher__get_property_description_by_classResponse:
		soap_serialize_switcher__get_property_description_by_classResponse(soap, (const struct switcher__get_property_description_by_classResponse *)ptr);
		break;
	case SOAP_TYPE_switcher__get_properties_description_by_class:
		soap_serialize_switcher__get_properties_description_by_class(soap, (const struct switcher__get_properties_description_by_class *)ptr);
		break;
	case SOAP_TYPE_switcher__get_properties_description_by_classResponse:
		soap_serialize_switcher__get_properties_description_by_classResponse(soap, (const struct switcher__get_properties_description_by_classResponse *)ptr);
		break;
	case SOAP_TYPE_switcher__get_property_description:
		soap_serialize_switcher__get_property_description(soap, (const struct switcher__get_property_description *)ptr);
		break;
	case SOAP_TYPE_switcher__get_property_descriptionResponse:
		soap_serialize_switcher__get_property_descriptionResponse(soap, (const struct switcher__get_property_descriptionResponse *)ptr);
		break;
	case SOAP_TYPE_switcher__get_properties_description:
		soap_serialize_switcher__get_properties_description(soap, (const struct switcher__get_properties_description *)ptr);
		break;
	case SOAP_TYPE_switcher__get_properties_descriptionResponse:
		soap_serialize_switcher__get_properties_descriptionResponse(soap, (const struct switcher__get_properties_descriptionResponse *)ptr);
		break;
	case SOAP_TYPE_switcher__get_quiddity_names:
		soap_serialize_switcher__get_quiddity_names(soap, (const struct switcher__get_quiddity_names *)ptr);
		break;
	case SOAP_TYPE_switcher__get_quiddity_namesResponse:
		soap_serialize_switcher__get_quiddity_namesResponse(soap, (const struct switcher__get_quiddity_namesResponse *)ptr);
		break;
	case SOAP_TYPE_switcher__get_class_doc:
		soap_serialize_switcher__get_class_doc(soap, (const struct switcher__get_class_doc *)ptr);
		break;
	case SOAP_TYPE_switcher__get_class_docResponse:
		soap_serialize_switcher__get_class_docResponse(soap, (const struct switcher__get_class_docResponse *)ptr);
		break;
	case SOAP_TYPE_switcher__get_quiddities_description:
		soap_serialize_switcher__get_quiddities_description(soap, (const struct switcher__get_quiddities_description *)ptr);
		break;
	case SOAP_TYPE_switcher__get_quiddities_descriptionResponse:
		soap_serialize_switcher__get_quiddities_descriptionResponse(soap, (const struct switcher__get_quiddities_descriptionResponse *)ptr);
		break;
	case SOAP_TYPE_switcher__get_quiddity_description:
		soap_serialize_switcher__get_quiddity_description(soap, (const struct switcher__get_quiddity_description *)ptr);
		break;
	case SOAP_TYPE_switcher__get_quiddity_descriptionResponse:
		soap_serialize_switcher__get_quiddity_descriptionResponse(soap, (const struct switcher__get_quiddity_descriptionResponse *)ptr);
		break;
	case SOAP_TYPE_switcher__get_classes_doc:
		soap_serialize_switcher__get_classes_doc(soap, (const struct switcher__get_classes_doc *)ptr);
		break;
	case SOAP_TYPE_switcher__get_classes_docResponse:
		soap_serialize_switcher__get_classes_docResponse(soap, (const struct switcher__get_classes_docResponse *)ptr);
		break;
	case SOAP_TYPE_switcher__get_factory_capabilities:
		soap_serialize_switcher__get_factory_capabilities(soap, (const struct switcher__get_factory_capabilities *)ptr);
		break;
	case SOAP_TYPE_switcher__get_factory_capabilitiesResponse:
		soap_serialize_switcher__get_factory_capabilitiesResponse(soap, (const struct switcher__get_factory_capabilitiesResponse *)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__get_factory_capabilitiesResponse:
		return (void*)soap_instantiate_switcher__get_factory_capabilitiesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__get_factory_capabilities:
		return (void*)soap_instantiate_switcher__get_factory_capabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__get_classes_docResponse:
		return (void*)soap_instantiate_switcher__get_classes_docResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__get_classes_doc:
		return (void*)soap_instantiate_switcher__get_classes_doc(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__get_quiddity_descriptionResponse:
		return (void*)soap_instantiate_switcher__get_quiddity_descriptionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__get_quiddity_description:
		return (void*)soap_instantiate_switcher__get_quiddity_description(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__get_quiddities_descriptionResponse:
		return (void*)soap_instantiate_switcher__get_quiddities_descriptionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__get_quiddities_description:
		return (void*)soap_instantiate_switcher__get_quiddities_description(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__get_class_docResponse:
		return (void*)soap_instantiate_switcher__get_class_docResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__get_class_doc:
		return (void*)soap_instantiate_switcher__get_class_doc(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__get_quiddity_namesResponse:
		return (void*)soap_instantiate_switcher__get_quiddity_namesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__get_quiddity_names:
		return (void*)soap_instantiate_switcher__get_quiddity_names(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__get_properties_descriptionResponse:
		return (void*)soap_instantiate_switcher__get_properties_descriptionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__get_properties_description:
		return (void*)soap_instantiate_switcher__get_properties_description(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__get_property_descriptionResponse:
		return (void*)soap_instantiate_switcher__get_property_descriptionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__get_property_description:
		return (void*)soap_instantiate_switcher__get_property_description(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__get_properties_description_by_classResponse:
		return (void*)soap_instantiate_switcher__get_properties_description_by_classResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__get_properties_description_by_class:
		return (void*)soap_instantiate_switcher__get_properties_description_by_class(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__get_property_description_by_classResponse:
		return (void*)soap_instantiate_switcher__get_property_description_by_classResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__get_property_description_by_class:
		return (void*)soap_instantiate_switcher__get_property_description_by_class(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__set_property:
		return (void*)soap_instantiate_switcher__set_property(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__get_propertyResponse:
		return (void*)soap_instantiate_switcher__get_propertyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__get_property:
		return (void*)soap_instantiate_switcher__get_property(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__create_quiddityResponse:
		return (void*)soap_instantiate_switcher__create_quiddityResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__create_quiddity:
		return (void*)soap_instantiate_switcher__create_quiddity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__create_named_quiddityResponse:
		return (void*)soap_instantiate_switcher__create_named_quiddityResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__create_named_quiddity:
		return (void*)soap_instantiate_switcher__create_named_quiddity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__rename_quiddityResponse:
		return (void*)soap_instantiate_switcher__rename_quiddityResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__rename_quiddity:
		return (void*)soap_instantiate_switcher__rename_quiddity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__delete_quiddity:
		return (void*)soap_instantiate_switcher__delete_quiddity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__get_methods_descriptionResponse:
		return (void*)soap_instantiate_switcher__get_methods_descriptionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__get_methods_description:
		return (void*)soap_instantiate_switcher__get_methods_description(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__get_method_descriptionResponse:
		return (void*)soap_instantiate_switcher__get_method_descriptionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__get_method_description:
		return (void*)soap_instantiate_switcher__get_method_description(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__get_methods_description_by_classResponse:
		return (void*)soap_instantiate_switcher__get_methods_description_by_classResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__get_methods_description_by_class:
		return (void*)soap_instantiate_switcher__get_methods_description_by_class(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__get_method_description_by_classResponse:
		return (void*)soap_instantiate_switcher__get_method_description_by_classResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__get_method_description_by_class:
		return (void*)soap_instantiate_switcher__get_method_description_by_class(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__invoke_methodResponse:
		return (void*)soap_instantiate_switcher__invoke_methodResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__invoke_method:
		return (void*)soap_instantiate_switcher__invoke_method(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__get_signals_descriptionResponse:
		return (void*)soap_instantiate_switcher__get_signals_descriptionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__get_signals_description:
		return (void*)soap_instantiate_switcher__get_signals_description(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__get_signal_descriptionResponse:
		return (void*)soap_instantiate_switcher__get_signal_descriptionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__get_signal_description:
		return (void*)soap_instantiate_switcher__get_signal_description(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__get_signals_description_by_classResponse:
		return (void*)soap_instantiate_switcher__get_signals_description_by_classResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__get_signals_description_by_class:
		return (void*)soap_instantiate_switcher__get_signals_description_by_class(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__saveResponse:
		return (void*)soap_instantiate_switcher__saveResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__save:
		return (void*)soap_instantiate_switcher__save(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__loadResponse:
		return (void*)soap_instantiate_switcher__loadResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__load:
		return (void*)soap_instantiate_switcher__load(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__runResponse:
		return (void*)soap_instantiate_switcher__runResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__run:
		return (void*)soap_instantiate_switcher__run(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__get_signal_description_by_classResponse:
		return (void*)soap_instantiate_switcher__get_signal_description_by_classResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_switcher__get_signal_description_by_class:
		return (void*)soap_instantiate_switcher__get_signal_description_by_class(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_switcher__get_factory_capabilitiesResponse:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__get_factory_capabilitiesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__get_factory_capabilitiesResponse*)p->ptr);
		break;
	case SOAP_TYPE_switcher__get_factory_capabilities:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__get_factory_capabilities*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__get_factory_capabilities*)p->ptr);
		break;
	case SOAP_TYPE_switcher__get_classes_docResponse:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__get_classes_docResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__get_classes_docResponse*)p->ptr);
		break;
	case SOAP_TYPE_switcher__get_classes_doc:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__get_classes_doc*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__get_classes_doc*)p->ptr);
		break;
	case SOAP_TYPE_switcher__get_quiddity_descriptionResponse:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__get_quiddity_descriptionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__get_quiddity_descriptionResponse*)p->ptr);
		break;
	case SOAP_TYPE_switcher__get_quiddity_description:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__get_quiddity_description*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__get_quiddity_description*)p->ptr);
		break;
	case SOAP_TYPE_switcher__get_quiddities_descriptionResponse:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__get_quiddities_descriptionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__get_quiddities_descriptionResponse*)p->ptr);
		break;
	case SOAP_TYPE_switcher__get_quiddities_description:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__get_quiddities_description*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__get_quiddities_description*)p->ptr);
		break;
	case SOAP_TYPE_switcher__get_class_docResponse:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__get_class_docResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__get_class_docResponse*)p->ptr);
		break;
	case SOAP_TYPE_switcher__get_class_doc:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__get_class_doc*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__get_class_doc*)p->ptr);
		break;
	case SOAP_TYPE_switcher__get_quiddity_namesResponse:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__get_quiddity_namesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__get_quiddity_namesResponse*)p->ptr);
		break;
	case SOAP_TYPE_switcher__get_quiddity_names:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__get_quiddity_names*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__get_quiddity_names*)p->ptr);
		break;
	case SOAP_TYPE_switcher__get_properties_descriptionResponse:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__get_properties_descriptionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__get_properties_descriptionResponse*)p->ptr);
		break;
	case SOAP_TYPE_switcher__get_properties_description:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__get_properties_description*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__get_properties_description*)p->ptr);
		break;
	case SOAP_TYPE_switcher__get_property_descriptionResponse:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__get_property_descriptionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__get_property_descriptionResponse*)p->ptr);
		break;
	case SOAP_TYPE_switcher__get_property_description:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__get_property_description*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__get_property_description*)p->ptr);
		break;
	case SOAP_TYPE_switcher__get_properties_description_by_classResponse:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__get_properties_description_by_classResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__get_properties_description_by_classResponse*)p->ptr);
		break;
	case SOAP_TYPE_switcher__get_properties_description_by_class:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__get_properties_description_by_class*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__get_properties_description_by_class*)p->ptr);
		break;
	case SOAP_TYPE_switcher__get_property_description_by_classResponse:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__get_property_description_by_classResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__get_property_description_by_classResponse*)p->ptr);
		break;
	case SOAP_TYPE_switcher__get_property_description_by_class:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__get_property_description_by_class*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__get_property_description_by_class*)p->ptr);
		break;
	case SOAP_TYPE_switcher__set_property:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__set_property*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__set_property*)p->ptr);
		break;
	case SOAP_TYPE_switcher__get_propertyResponse:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__get_propertyResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__get_propertyResponse*)p->ptr);
		break;
	case SOAP_TYPE_switcher__get_property:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__get_property*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__get_property*)p->ptr);
		break;
	case SOAP_TYPE_switcher__create_quiddityResponse:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__create_quiddityResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__create_quiddityResponse*)p->ptr);
		break;
	case SOAP_TYPE_switcher__create_quiddity:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__create_quiddity*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__create_quiddity*)p->ptr);
		break;
	case SOAP_TYPE_switcher__create_named_quiddityResponse:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__create_named_quiddityResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__create_named_quiddityResponse*)p->ptr);
		break;
	case SOAP_TYPE_switcher__create_named_quiddity:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__create_named_quiddity*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__create_named_quiddity*)p->ptr);
		break;
	case SOAP_TYPE_switcher__rename_quiddityResponse:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__rename_quiddityResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__rename_quiddityResponse*)p->ptr);
		break;
	case SOAP_TYPE_switcher__rename_quiddity:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__rename_quiddity*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__rename_quiddity*)p->ptr);
		break;
	case SOAP_TYPE_switcher__delete_quiddity:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__delete_quiddity*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__delete_quiddity*)p->ptr);
		break;
	case SOAP_TYPE_switcher__get_methods_descriptionResponse:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__get_methods_descriptionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__get_methods_descriptionResponse*)p->ptr);
		break;
	case SOAP_TYPE_switcher__get_methods_description:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__get_methods_description*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__get_methods_description*)p->ptr);
		break;
	case SOAP_TYPE_switcher__get_method_descriptionResponse:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__get_method_descriptionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__get_method_descriptionResponse*)p->ptr);
		break;
	case SOAP_TYPE_switcher__get_method_description:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__get_method_description*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__get_method_description*)p->ptr);
		break;
	case SOAP_TYPE_switcher__get_methods_description_by_classResponse:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__get_methods_description_by_classResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__get_methods_description_by_classResponse*)p->ptr);
		break;
	case SOAP_TYPE_switcher__get_methods_description_by_class:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__get_methods_description_by_class*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__get_methods_description_by_class*)p->ptr);
		break;
	case SOAP_TYPE_switcher__get_method_description_by_classResponse:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__get_method_description_by_classResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__get_method_description_by_classResponse*)p->ptr);
		break;
	case SOAP_TYPE_switcher__get_method_description_by_class:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__get_method_description_by_class*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__get_method_description_by_class*)p->ptr);
		break;
	case SOAP_TYPE_switcher__invoke_methodResponse:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__invoke_methodResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__invoke_methodResponse*)p->ptr);
		break;
	case SOAP_TYPE_switcher__invoke_method:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__invoke_method*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__invoke_method*)p->ptr);
		break;
	case SOAP_TYPE_switcher__get_signals_descriptionResponse:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__get_signals_descriptionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__get_signals_descriptionResponse*)p->ptr);
		break;
	case SOAP_TYPE_switcher__get_signals_description:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__get_signals_description*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__get_signals_description*)p->ptr);
		break;
	case SOAP_TYPE_switcher__get_signal_descriptionResponse:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__get_signal_descriptionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__get_signal_descriptionResponse*)p->ptr);
		break;
	case SOAP_TYPE_switcher__get_signal_description:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__get_signal_description*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__get_signal_description*)p->ptr);
		break;
	case SOAP_TYPE_switcher__get_signals_description_by_classResponse:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__get_signals_description_by_classResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__get_signals_description_by_classResponse*)p->ptr);
		break;
	case SOAP_TYPE_switcher__get_signals_description_by_class:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__get_signals_description_by_class*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__get_signals_description_by_class*)p->ptr);
		break;
	case SOAP_TYPE_switcher__saveResponse:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__saveResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__saveResponse*)p->ptr);
		break;
	case SOAP_TYPE_switcher__save:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__save*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__save*)p->ptr);
		break;
	case SOAP_TYPE_switcher__loadResponse:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__loadResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__loadResponse*)p->ptr);
		break;
	case SOAP_TYPE_switcher__load:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__load*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__load*)p->ptr);
		break;
	case SOAP_TYPE_switcher__runResponse:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__runResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__runResponse*)p->ptr);
		break;
	case SOAP_TYPE_switcher__run:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__run*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__run*)p->ptr);
		break;
	case SOAP_TYPE_switcher__get_signal_description_by_classResponse:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__get_signal_description_by_classResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__get_signal_description_by_classResponse*)p->ptr);
		break;
	case SOAP_TYPE_switcher__get_signal_description_by_class:
		if (p->size < 0)
			SOAP_DELETE((struct switcher__get_signal_description_by_class*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct switcher__get_signal_description_by_class*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			SOAP_DELETE((std::vector<std::string >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<std::string >*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::string[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__get_signal_description_by_class(struct soap *soap, struct switcher__get_signal_description_by_class *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->class_name);
	soap_default_std__string(soap, &a->signal_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__get_signal_description_by_class(struct soap *soap, const struct switcher__get_signal_description_by_class *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->class_name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->class_name);
	soap_embedded(soap, &a->signal_name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->signal_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__get_signal_description_by_class(struct soap *soap, const char *tag, int id, const struct switcher__get_signal_description_by_class *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__get_signal_description_by_class), type))
		return soap->error;
	if (soap_out_std__string(soap, "class-name", -1, &a->class_name, ""))
		return soap->error;
	if (soap_out_std__string(soap, "signal-name", -1, &a->signal_name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__get_signal_description_by_class * SOAP_FMAC4 soap_in_switcher__get_signal_description_by_class(struct soap *soap, const char *tag, struct switcher__get_signal_description_by_class *a, const char *type)
{
	size_t soap_flag_class_name = 1;
	size_t soap_flag_signal_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__get_signal_description_by_class *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__get_signal_description_by_class, sizeof(struct switcher__get_signal_description_by_class), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_switcher__get_signal_description_by_class(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_class_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "class-name", &a->class_name, "xsd:string"))
				{	soap_flag_class_name--;
					continue;
				}
			if (soap_flag_signal_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "signal-name", &a->signal_name, "xsd:string"))
				{	soap_flag_signal_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__get_signal_description_by_class *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__get_signal_description_by_class, 0, sizeof(struct switcher__get_signal_description_by_class), 0, soap_copy_switcher__get_signal_description_by_class);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_class_name > 0 || soap_flag_signal_name > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__get_signal_description_by_class(struct soap *soap, const struct switcher__get_signal_description_by_class *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__get_signal_description_by_class);
	if (soap_out_switcher__get_signal_description_by_class(soap, tag?tag:"switcher:get-signal-description-by-class", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__get_signal_description_by_class * SOAP_FMAC4 soap_get_switcher__get_signal_description_by_class(struct soap *soap, struct switcher__get_signal_description_by_class *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__get_signal_description_by_class(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__get_signal_description_by_class * SOAP_FMAC2 soap_instantiate_switcher__get_signal_description_by_class(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__get_signal_description_by_class(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__get_signal_description_by_class, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_signal_description_by_class);
		if (size)
			*size = sizeof(struct switcher__get_signal_description_by_class);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_signal_description_by_class[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__get_signal_description_by_class);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__get_signal_description_by_class*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__get_signal_description_by_class(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__get_signal_description_by_class %p -> %p\n", q, p));
	*(struct switcher__get_signal_description_by_class*)p = *(struct switcher__get_signal_description_by_class*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__get_signal_description_by_classResponse(struct soap *soap, struct switcher__get_signal_description_by_classResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__get_signal_description_by_classResponse(struct soap *soap, const struct switcher__get_signal_description_by_classResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__get_signal_description_by_classResponse(struct soap *soap, const char *tag, int id, const struct switcher__get_signal_description_by_classResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__get_signal_description_by_classResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__get_signal_description_by_classResponse * SOAP_FMAC4 soap_in_switcher__get_signal_description_by_classResponse(struct soap *soap, const char *tag, struct switcher__get_signal_description_by_classResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__get_signal_description_by_classResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__get_signal_description_by_classResponse, sizeof(struct switcher__get_signal_description_by_classResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_switcher__get_signal_description_by_classResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__get_signal_description_by_classResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__get_signal_description_by_classResponse, 0, sizeof(struct switcher__get_signal_description_by_classResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__get_signal_description_by_classResponse(struct soap *soap, const struct switcher__get_signal_description_by_classResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__get_signal_description_by_classResponse);
	if (soap_out_switcher__get_signal_description_by_classResponse(soap, tag?tag:"switcher:get-signal-description-by-classResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__get_signal_description_by_classResponse * SOAP_FMAC4 soap_get_switcher__get_signal_description_by_classResponse(struct soap *soap, struct switcher__get_signal_description_by_classResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__get_signal_description_by_classResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__get_signal_description_by_classResponse * SOAP_FMAC2 soap_instantiate_switcher__get_signal_description_by_classResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__get_signal_description_by_classResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__get_signal_description_by_classResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_signal_description_by_classResponse);
		if (size)
			*size = sizeof(struct switcher__get_signal_description_by_classResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_signal_description_by_classResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__get_signal_description_by_classResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__get_signal_description_by_classResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__get_signal_description_by_classResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__get_signal_description_by_classResponse %p -> %p\n", q, p));
	*(struct switcher__get_signal_description_by_classResponse*)p = *(struct switcher__get_signal_description_by_classResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__run(struct soap *soap, struct switcher__run *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->file_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__run(struct soap *soap, const struct switcher__run *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->file_name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->file_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__run(struct soap *soap, const char *tag, int id, const struct switcher__run *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__run), type))
		return soap->error;
	if (soap_out_std__string(soap, "file-name", -1, &a->file_name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__run * SOAP_FMAC4 soap_in_switcher__run(struct soap *soap, const char *tag, struct switcher__run *a, const char *type)
{
	size_t soap_flag_file_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__run *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__run, sizeof(struct switcher__run), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_switcher__run(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_file_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "file-name", &a->file_name, "xsd:string"))
				{	soap_flag_file_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__run *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__run, 0, sizeof(struct switcher__run), 0, soap_copy_switcher__run);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_file_name > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__run(struct soap *soap, const struct switcher__run *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__run);
	if (soap_out_switcher__run(soap, tag?tag:"switcher:run", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__run * SOAP_FMAC4 soap_get_switcher__run(struct soap *soap, struct switcher__run *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__run(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__run * SOAP_FMAC2 soap_instantiate_switcher__run(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__run(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__run, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__run);
		if (size)
			*size = sizeof(struct switcher__run);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__run[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__run);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__run*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__run(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__run %p -> %p\n", q, p));
	*(struct switcher__run*)p = *(struct switcher__run*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__runResponse(struct soap *soap, struct switcher__runResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__runResponse(struct soap *soap, const struct switcher__runResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__runResponse(struct soap *soap, const char *tag, int id, const struct switcher__runResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__runResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__runResponse * SOAP_FMAC4 soap_in_switcher__runResponse(struct soap *soap, const char *tag, struct switcher__runResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__runResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__runResponse, sizeof(struct switcher__runResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_switcher__runResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__runResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__runResponse, 0, sizeof(struct switcher__runResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__runResponse(struct soap *soap, const struct switcher__runResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__runResponse);
	if (soap_out_switcher__runResponse(soap, tag?tag:"switcher:runResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__runResponse * SOAP_FMAC4 soap_get_switcher__runResponse(struct soap *soap, struct switcher__runResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__runResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__runResponse * SOAP_FMAC2 soap_instantiate_switcher__runResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__runResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__runResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__runResponse);
		if (size)
			*size = sizeof(struct switcher__runResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__runResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__runResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__runResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__runResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__runResponse %p -> %p\n", q, p));
	*(struct switcher__runResponse*)p = *(struct switcher__runResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__load(struct soap *soap, struct switcher__load *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->file_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__load(struct soap *soap, const struct switcher__load *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->file_name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->file_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__load(struct soap *soap, const char *tag, int id, const struct switcher__load *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__load), type))
		return soap->error;
	if (soap_out_std__string(soap, "file-name", -1, &a->file_name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__load * SOAP_FMAC4 soap_in_switcher__load(struct soap *soap, const char *tag, struct switcher__load *a, const char *type)
{
	size_t soap_flag_file_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__load *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__load, sizeof(struct switcher__load), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_switcher__load(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_file_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "file-name", &a->file_name, "xsd:string"))
				{	soap_flag_file_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__load *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__load, 0, sizeof(struct switcher__load), 0, soap_copy_switcher__load);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_file_name > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__load(struct soap *soap, const struct switcher__load *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__load);
	if (soap_out_switcher__load(soap, tag?tag:"switcher:load", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__load * SOAP_FMAC4 soap_get_switcher__load(struct soap *soap, struct switcher__load *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__load(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__load * SOAP_FMAC2 soap_instantiate_switcher__load(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__load(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__load, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__load);
		if (size)
			*size = sizeof(struct switcher__load);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__load[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__load);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__load*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__load(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__load %p -> %p\n", q, p));
	*(struct switcher__load*)p = *(struct switcher__load*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__loadResponse(struct soap *soap, struct switcher__loadResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__loadResponse(struct soap *soap, const struct switcher__loadResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__loadResponse(struct soap *soap, const char *tag, int id, const struct switcher__loadResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__loadResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__loadResponse * SOAP_FMAC4 soap_in_switcher__loadResponse(struct soap *soap, const char *tag, struct switcher__loadResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__loadResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__loadResponse, sizeof(struct switcher__loadResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_switcher__loadResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__loadResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__loadResponse, 0, sizeof(struct switcher__loadResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__loadResponse(struct soap *soap, const struct switcher__loadResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__loadResponse);
	if (soap_out_switcher__loadResponse(soap, tag?tag:"switcher:loadResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__loadResponse * SOAP_FMAC4 soap_get_switcher__loadResponse(struct soap *soap, struct switcher__loadResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__loadResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__loadResponse * SOAP_FMAC2 soap_instantiate_switcher__loadResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__loadResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__loadResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__loadResponse);
		if (size)
			*size = sizeof(struct switcher__loadResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__loadResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__loadResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__loadResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__loadResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__loadResponse %p -> %p\n", q, p));
	*(struct switcher__loadResponse*)p = *(struct switcher__loadResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__save(struct soap *soap, struct switcher__save *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->file_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__save(struct soap *soap, const struct switcher__save *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->file_name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->file_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__save(struct soap *soap, const char *tag, int id, const struct switcher__save *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__save), type))
		return soap->error;
	if (soap_out_std__string(soap, "file-name", -1, &a->file_name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__save * SOAP_FMAC4 soap_in_switcher__save(struct soap *soap, const char *tag, struct switcher__save *a, const char *type)
{
	size_t soap_flag_file_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__save *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__save, sizeof(struct switcher__save), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_switcher__save(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_file_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "file-name", &a->file_name, "xsd:string"))
				{	soap_flag_file_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__save *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__save, 0, sizeof(struct switcher__save), 0, soap_copy_switcher__save);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_file_name > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__save(struct soap *soap, const struct switcher__save *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__save);
	if (soap_out_switcher__save(soap, tag?tag:"switcher:save", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__save * SOAP_FMAC4 soap_get_switcher__save(struct soap *soap, struct switcher__save *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__save(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__save * SOAP_FMAC2 soap_instantiate_switcher__save(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__save(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__save, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__save);
		if (size)
			*size = sizeof(struct switcher__save);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__save[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__save);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__save*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__save(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__save %p -> %p\n", q, p));
	*(struct switcher__save*)p = *(struct switcher__save*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__saveResponse(struct soap *soap, struct switcher__saveResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__saveResponse(struct soap *soap, const struct switcher__saveResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__saveResponse(struct soap *soap, const char *tag, int id, const struct switcher__saveResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__saveResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__saveResponse * SOAP_FMAC4 soap_in_switcher__saveResponse(struct soap *soap, const char *tag, struct switcher__saveResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__saveResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__saveResponse, sizeof(struct switcher__saveResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_switcher__saveResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__saveResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__saveResponse, 0, sizeof(struct switcher__saveResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__saveResponse(struct soap *soap, const struct switcher__saveResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__saveResponse);
	if (soap_out_switcher__saveResponse(soap, tag?tag:"switcher:saveResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__saveResponse * SOAP_FMAC4 soap_get_switcher__saveResponse(struct soap *soap, struct switcher__saveResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__saveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__saveResponse * SOAP_FMAC2 soap_instantiate_switcher__saveResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__saveResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__saveResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__saveResponse);
		if (size)
			*size = sizeof(struct switcher__saveResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__saveResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__saveResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__saveResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__saveResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__saveResponse %p -> %p\n", q, p));
	*(struct switcher__saveResponse*)p = *(struct switcher__saveResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__get_signals_description_by_class(struct soap *soap, struct switcher__get_signals_description_by_class *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->class_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__get_signals_description_by_class(struct soap *soap, const struct switcher__get_signals_description_by_class *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->class_name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->class_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__get_signals_description_by_class(struct soap *soap, const char *tag, int id, const struct switcher__get_signals_description_by_class *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__get_signals_description_by_class), type))
		return soap->error;
	if (soap_out_std__string(soap, "class-name", -1, &a->class_name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__get_signals_description_by_class * SOAP_FMAC4 soap_in_switcher__get_signals_description_by_class(struct soap *soap, const char *tag, struct switcher__get_signals_description_by_class *a, const char *type)
{
	size_t soap_flag_class_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__get_signals_description_by_class *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__get_signals_description_by_class, sizeof(struct switcher__get_signals_description_by_class), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_switcher__get_signals_description_by_class(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_class_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "class-name", &a->class_name, "xsd:string"))
				{	soap_flag_class_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__get_signals_description_by_class *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__get_signals_description_by_class, 0, sizeof(struct switcher__get_signals_description_by_class), 0, soap_copy_switcher__get_signals_description_by_class);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_class_name > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__get_signals_description_by_class(struct soap *soap, const struct switcher__get_signals_description_by_class *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__get_signals_description_by_class);
	if (soap_out_switcher__get_signals_description_by_class(soap, tag?tag:"switcher:get-signals-description-by-class", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__get_signals_description_by_class * SOAP_FMAC4 soap_get_switcher__get_signals_description_by_class(struct soap *soap, struct switcher__get_signals_description_by_class *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__get_signals_description_by_class(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__get_signals_description_by_class * SOAP_FMAC2 soap_instantiate_switcher__get_signals_description_by_class(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__get_signals_description_by_class(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__get_signals_description_by_class, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_signals_description_by_class);
		if (size)
			*size = sizeof(struct switcher__get_signals_description_by_class);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_signals_description_by_class[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__get_signals_description_by_class);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__get_signals_description_by_class*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__get_signals_description_by_class(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__get_signals_description_by_class %p -> %p\n", q, p));
	*(struct switcher__get_signals_description_by_class*)p = *(struct switcher__get_signals_description_by_class*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__get_signals_description_by_classResponse(struct soap *soap, struct switcher__get_signals_description_by_classResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__get_signals_description_by_classResponse(struct soap *soap, const struct switcher__get_signals_description_by_classResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__get_signals_description_by_classResponse(struct soap *soap, const char *tag, int id, const struct switcher__get_signals_description_by_classResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__get_signals_description_by_classResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__get_signals_description_by_classResponse * SOAP_FMAC4 soap_in_switcher__get_signals_description_by_classResponse(struct soap *soap, const char *tag, struct switcher__get_signals_description_by_classResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__get_signals_description_by_classResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__get_signals_description_by_classResponse, sizeof(struct switcher__get_signals_description_by_classResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_switcher__get_signals_description_by_classResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__get_signals_description_by_classResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__get_signals_description_by_classResponse, 0, sizeof(struct switcher__get_signals_description_by_classResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__get_signals_description_by_classResponse(struct soap *soap, const struct switcher__get_signals_description_by_classResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__get_signals_description_by_classResponse);
	if (soap_out_switcher__get_signals_description_by_classResponse(soap, tag?tag:"switcher:get-signals-description-by-classResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__get_signals_description_by_classResponse * SOAP_FMAC4 soap_get_switcher__get_signals_description_by_classResponse(struct soap *soap, struct switcher__get_signals_description_by_classResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__get_signals_description_by_classResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__get_signals_description_by_classResponse * SOAP_FMAC2 soap_instantiate_switcher__get_signals_description_by_classResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__get_signals_description_by_classResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__get_signals_description_by_classResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_signals_description_by_classResponse);
		if (size)
			*size = sizeof(struct switcher__get_signals_description_by_classResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_signals_description_by_classResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__get_signals_description_by_classResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__get_signals_description_by_classResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__get_signals_description_by_classResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__get_signals_description_by_classResponse %p -> %p\n", q, p));
	*(struct switcher__get_signals_description_by_classResponse*)p = *(struct switcher__get_signals_description_by_classResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__get_signal_description(struct soap *soap, struct switcher__get_signal_description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->quiddity_name);
	soap_default_std__string(soap, &a->signal_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__get_signal_description(struct soap *soap, const struct switcher__get_signal_description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->quiddity_name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->quiddity_name);
	soap_embedded(soap, &a->signal_name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->signal_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__get_signal_description(struct soap *soap, const char *tag, int id, const struct switcher__get_signal_description *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__get_signal_description), type))
		return soap->error;
	if (soap_out_std__string(soap, "quiddity-name", -1, &a->quiddity_name, ""))
		return soap->error;
	if (soap_out_std__string(soap, "signal-name", -1, &a->signal_name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__get_signal_description * SOAP_FMAC4 soap_in_switcher__get_signal_description(struct soap *soap, const char *tag, struct switcher__get_signal_description *a, const char *type)
{
	size_t soap_flag_quiddity_name = 1;
	size_t soap_flag_signal_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__get_signal_description *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__get_signal_description, sizeof(struct switcher__get_signal_description), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_switcher__get_signal_description(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_quiddity_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "quiddity-name", &a->quiddity_name, "xsd:string"))
				{	soap_flag_quiddity_name--;
					continue;
				}
			if (soap_flag_signal_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "signal-name", &a->signal_name, "xsd:string"))
				{	soap_flag_signal_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__get_signal_description *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__get_signal_description, 0, sizeof(struct switcher__get_signal_description), 0, soap_copy_switcher__get_signal_description);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_quiddity_name > 0 || soap_flag_signal_name > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__get_signal_description(struct soap *soap, const struct switcher__get_signal_description *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__get_signal_description);
	if (soap_out_switcher__get_signal_description(soap, tag?tag:"switcher:get-signal-description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__get_signal_description * SOAP_FMAC4 soap_get_switcher__get_signal_description(struct soap *soap, struct switcher__get_signal_description *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__get_signal_description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__get_signal_description * SOAP_FMAC2 soap_instantiate_switcher__get_signal_description(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__get_signal_description(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__get_signal_description, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_signal_description);
		if (size)
			*size = sizeof(struct switcher__get_signal_description);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_signal_description[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__get_signal_description);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__get_signal_description*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__get_signal_description(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__get_signal_description %p -> %p\n", q, p));
	*(struct switcher__get_signal_description*)p = *(struct switcher__get_signal_description*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__get_signal_descriptionResponse(struct soap *soap, struct switcher__get_signal_descriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__get_signal_descriptionResponse(struct soap *soap, const struct switcher__get_signal_descriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__get_signal_descriptionResponse(struct soap *soap, const char *tag, int id, const struct switcher__get_signal_descriptionResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__get_signal_descriptionResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__get_signal_descriptionResponse * SOAP_FMAC4 soap_in_switcher__get_signal_descriptionResponse(struct soap *soap, const char *tag, struct switcher__get_signal_descriptionResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__get_signal_descriptionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__get_signal_descriptionResponse, sizeof(struct switcher__get_signal_descriptionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_switcher__get_signal_descriptionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__get_signal_descriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__get_signal_descriptionResponse, 0, sizeof(struct switcher__get_signal_descriptionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__get_signal_descriptionResponse(struct soap *soap, const struct switcher__get_signal_descriptionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__get_signal_descriptionResponse);
	if (soap_out_switcher__get_signal_descriptionResponse(soap, tag?tag:"switcher:get-signal-descriptionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__get_signal_descriptionResponse * SOAP_FMAC4 soap_get_switcher__get_signal_descriptionResponse(struct soap *soap, struct switcher__get_signal_descriptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__get_signal_descriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__get_signal_descriptionResponse * SOAP_FMAC2 soap_instantiate_switcher__get_signal_descriptionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__get_signal_descriptionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__get_signal_descriptionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_signal_descriptionResponse);
		if (size)
			*size = sizeof(struct switcher__get_signal_descriptionResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_signal_descriptionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__get_signal_descriptionResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__get_signal_descriptionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__get_signal_descriptionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__get_signal_descriptionResponse %p -> %p\n", q, p));
	*(struct switcher__get_signal_descriptionResponse*)p = *(struct switcher__get_signal_descriptionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__get_signals_description(struct soap *soap, struct switcher__get_signals_description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->quiddity_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__get_signals_description(struct soap *soap, const struct switcher__get_signals_description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->quiddity_name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->quiddity_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__get_signals_description(struct soap *soap, const char *tag, int id, const struct switcher__get_signals_description *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__get_signals_description), type))
		return soap->error;
	if (soap_out_std__string(soap, "quiddity-name", -1, &a->quiddity_name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__get_signals_description * SOAP_FMAC4 soap_in_switcher__get_signals_description(struct soap *soap, const char *tag, struct switcher__get_signals_description *a, const char *type)
{
	size_t soap_flag_quiddity_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__get_signals_description *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__get_signals_description, sizeof(struct switcher__get_signals_description), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_switcher__get_signals_description(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_quiddity_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "quiddity-name", &a->quiddity_name, "xsd:string"))
				{	soap_flag_quiddity_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__get_signals_description *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__get_signals_description, 0, sizeof(struct switcher__get_signals_description), 0, soap_copy_switcher__get_signals_description);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_quiddity_name > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__get_signals_description(struct soap *soap, const struct switcher__get_signals_description *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__get_signals_description);
	if (soap_out_switcher__get_signals_description(soap, tag?tag:"switcher:get-signals-description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__get_signals_description * SOAP_FMAC4 soap_get_switcher__get_signals_description(struct soap *soap, struct switcher__get_signals_description *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__get_signals_description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__get_signals_description * SOAP_FMAC2 soap_instantiate_switcher__get_signals_description(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__get_signals_description(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__get_signals_description, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_signals_description);
		if (size)
			*size = sizeof(struct switcher__get_signals_description);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_signals_description[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__get_signals_description);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__get_signals_description*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__get_signals_description(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__get_signals_description %p -> %p\n", q, p));
	*(struct switcher__get_signals_description*)p = *(struct switcher__get_signals_description*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__get_signals_descriptionResponse(struct soap *soap, struct switcher__get_signals_descriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__get_signals_descriptionResponse(struct soap *soap, const struct switcher__get_signals_descriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__get_signals_descriptionResponse(struct soap *soap, const char *tag, int id, const struct switcher__get_signals_descriptionResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__get_signals_descriptionResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__get_signals_descriptionResponse * SOAP_FMAC4 soap_in_switcher__get_signals_descriptionResponse(struct soap *soap, const char *tag, struct switcher__get_signals_descriptionResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__get_signals_descriptionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__get_signals_descriptionResponse, sizeof(struct switcher__get_signals_descriptionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_switcher__get_signals_descriptionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__get_signals_descriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__get_signals_descriptionResponse, 0, sizeof(struct switcher__get_signals_descriptionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__get_signals_descriptionResponse(struct soap *soap, const struct switcher__get_signals_descriptionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__get_signals_descriptionResponse);
	if (soap_out_switcher__get_signals_descriptionResponse(soap, tag?tag:"switcher:get-signals-descriptionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__get_signals_descriptionResponse * SOAP_FMAC4 soap_get_switcher__get_signals_descriptionResponse(struct soap *soap, struct switcher__get_signals_descriptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__get_signals_descriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__get_signals_descriptionResponse * SOAP_FMAC2 soap_instantiate_switcher__get_signals_descriptionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__get_signals_descriptionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__get_signals_descriptionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_signals_descriptionResponse);
		if (size)
			*size = sizeof(struct switcher__get_signals_descriptionResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_signals_descriptionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__get_signals_descriptionResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__get_signals_descriptionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__get_signals_descriptionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__get_signals_descriptionResponse %p -> %p\n", q, p));
	*(struct switcher__get_signals_descriptionResponse*)p = *(struct switcher__get_signals_descriptionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__invoke_method(struct soap *soap, struct switcher__invoke_method *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->quiddity_name);
	soap_default_std__string(soap, &a->method_name);
	soap_default_std__vectorTemplateOfstd__string(soap, &a->args);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__invoke_method(struct soap *soap, const struct switcher__invoke_method *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->quiddity_name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->quiddity_name);
	soap_embedded(soap, &a->method_name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->method_name);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &a->args);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__invoke_method(struct soap *soap, const char *tag, int id, const struct switcher__invoke_method *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__invoke_method), type))
		return soap->error;
	if (soap_out_std__string(soap, "quiddity-name", -1, &a->quiddity_name, ""))
		return soap->error;
	if (soap_out_std__string(soap, "method-name", -1, &a->method_name, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "args", -1, &a->args, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__invoke_method * SOAP_FMAC4 soap_in_switcher__invoke_method(struct soap *soap, const char *tag, struct switcher__invoke_method *a, const char *type)
{
	size_t soap_flag_quiddity_name = 1;
	size_t soap_flag_method_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__invoke_method *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__invoke_method, sizeof(struct switcher__invoke_method), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_switcher__invoke_method(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_quiddity_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "quiddity-name", &a->quiddity_name, "xsd:string"))
				{	soap_flag_quiddity_name--;
					continue;
				}
			if (soap_flag_method_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "method-name", &a->method_name, "xsd:string"))
				{	soap_flag_method_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "args", &a->args, "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__invoke_method *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__invoke_method, 0, sizeof(struct switcher__invoke_method), 0, soap_copy_switcher__invoke_method);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_quiddity_name > 0 || soap_flag_method_name > 0 || a->args.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__invoke_method(struct soap *soap, const struct switcher__invoke_method *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__invoke_method);
	if (soap_out_switcher__invoke_method(soap, tag?tag:"switcher:invoke-method", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__invoke_method * SOAP_FMAC4 soap_get_switcher__invoke_method(struct soap *soap, struct switcher__invoke_method *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__invoke_method(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__invoke_method * SOAP_FMAC2 soap_instantiate_switcher__invoke_method(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__invoke_method(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__invoke_method, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__invoke_method);
		if (size)
			*size = sizeof(struct switcher__invoke_method);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__invoke_method[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__invoke_method);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__invoke_method*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__invoke_method(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__invoke_method %p -> %p\n", q, p));
	*(struct switcher__invoke_method*)p = *(struct switcher__invoke_method*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__invoke_methodResponse(struct soap *soap, struct switcher__invoke_methodResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__invoke_methodResponse(struct soap *soap, const struct switcher__invoke_methodResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__invoke_methodResponse(struct soap *soap, const char *tag, int id, const struct switcher__invoke_methodResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__invoke_methodResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__invoke_methodResponse * SOAP_FMAC4 soap_in_switcher__invoke_methodResponse(struct soap *soap, const char *tag, struct switcher__invoke_methodResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__invoke_methodResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__invoke_methodResponse, sizeof(struct switcher__invoke_methodResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_switcher__invoke_methodResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__invoke_methodResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__invoke_methodResponse, 0, sizeof(struct switcher__invoke_methodResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__invoke_methodResponse(struct soap *soap, const struct switcher__invoke_methodResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__invoke_methodResponse);
	if (soap_out_switcher__invoke_methodResponse(soap, tag?tag:"switcher:invoke-methodResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__invoke_methodResponse * SOAP_FMAC4 soap_get_switcher__invoke_methodResponse(struct soap *soap, struct switcher__invoke_methodResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__invoke_methodResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__invoke_methodResponse * SOAP_FMAC2 soap_instantiate_switcher__invoke_methodResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__invoke_methodResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__invoke_methodResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__invoke_methodResponse);
		if (size)
			*size = sizeof(struct switcher__invoke_methodResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__invoke_methodResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__invoke_methodResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__invoke_methodResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__invoke_methodResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__invoke_methodResponse %p -> %p\n", q, p));
	*(struct switcher__invoke_methodResponse*)p = *(struct switcher__invoke_methodResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__get_method_description_by_class(struct soap *soap, struct switcher__get_method_description_by_class *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->class_name);
	soap_default_std__string(soap, &a->method_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__get_method_description_by_class(struct soap *soap, const struct switcher__get_method_description_by_class *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->class_name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->class_name);
	soap_embedded(soap, &a->method_name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->method_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__get_method_description_by_class(struct soap *soap, const char *tag, int id, const struct switcher__get_method_description_by_class *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__get_method_description_by_class), type))
		return soap->error;
	if (soap_out_std__string(soap, "class-name", -1, &a->class_name, ""))
		return soap->error;
	if (soap_out_std__string(soap, "method-name", -1, &a->method_name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__get_method_description_by_class * SOAP_FMAC4 soap_in_switcher__get_method_description_by_class(struct soap *soap, const char *tag, struct switcher__get_method_description_by_class *a, const char *type)
{
	size_t soap_flag_class_name = 1;
	size_t soap_flag_method_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__get_method_description_by_class *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__get_method_description_by_class, sizeof(struct switcher__get_method_description_by_class), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_switcher__get_method_description_by_class(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_class_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "class-name", &a->class_name, "xsd:string"))
				{	soap_flag_class_name--;
					continue;
				}
			if (soap_flag_method_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "method-name", &a->method_name, "xsd:string"))
				{	soap_flag_method_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__get_method_description_by_class *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__get_method_description_by_class, 0, sizeof(struct switcher__get_method_description_by_class), 0, soap_copy_switcher__get_method_description_by_class);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_class_name > 0 || soap_flag_method_name > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__get_method_description_by_class(struct soap *soap, const struct switcher__get_method_description_by_class *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__get_method_description_by_class);
	if (soap_out_switcher__get_method_description_by_class(soap, tag?tag:"switcher:get-method-description-by-class", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__get_method_description_by_class * SOAP_FMAC4 soap_get_switcher__get_method_description_by_class(struct soap *soap, struct switcher__get_method_description_by_class *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__get_method_description_by_class(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__get_method_description_by_class * SOAP_FMAC2 soap_instantiate_switcher__get_method_description_by_class(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__get_method_description_by_class(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__get_method_description_by_class, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_method_description_by_class);
		if (size)
			*size = sizeof(struct switcher__get_method_description_by_class);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_method_description_by_class[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__get_method_description_by_class);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__get_method_description_by_class*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__get_method_description_by_class(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__get_method_description_by_class %p -> %p\n", q, p));
	*(struct switcher__get_method_description_by_class*)p = *(struct switcher__get_method_description_by_class*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__get_method_description_by_classResponse(struct soap *soap, struct switcher__get_method_description_by_classResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__get_method_description_by_classResponse(struct soap *soap, const struct switcher__get_method_description_by_classResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__get_method_description_by_classResponse(struct soap *soap, const char *tag, int id, const struct switcher__get_method_description_by_classResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__get_method_description_by_classResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__get_method_description_by_classResponse * SOAP_FMAC4 soap_in_switcher__get_method_description_by_classResponse(struct soap *soap, const char *tag, struct switcher__get_method_description_by_classResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__get_method_description_by_classResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__get_method_description_by_classResponse, sizeof(struct switcher__get_method_description_by_classResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_switcher__get_method_description_by_classResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__get_method_description_by_classResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__get_method_description_by_classResponse, 0, sizeof(struct switcher__get_method_description_by_classResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__get_method_description_by_classResponse(struct soap *soap, const struct switcher__get_method_description_by_classResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__get_method_description_by_classResponse);
	if (soap_out_switcher__get_method_description_by_classResponse(soap, tag?tag:"switcher:get-method-description-by-classResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__get_method_description_by_classResponse * SOAP_FMAC4 soap_get_switcher__get_method_description_by_classResponse(struct soap *soap, struct switcher__get_method_description_by_classResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__get_method_description_by_classResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__get_method_description_by_classResponse * SOAP_FMAC2 soap_instantiate_switcher__get_method_description_by_classResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__get_method_description_by_classResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__get_method_description_by_classResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_method_description_by_classResponse);
		if (size)
			*size = sizeof(struct switcher__get_method_description_by_classResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_method_description_by_classResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__get_method_description_by_classResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__get_method_description_by_classResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__get_method_description_by_classResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__get_method_description_by_classResponse %p -> %p\n", q, p));
	*(struct switcher__get_method_description_by_classResponse*)p = *(struct switcher__get_method_description_by_classResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__get_methods_description_by_class(struct soap *soap, struct switcher__get_methods_description_by_class *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->class_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__get_methods_description_by_class(struct soap *soap, const struct switcher__get_methods_description_by_class *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->class_name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->class_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__get_methods_description_by_class(struct soap *soap, const char *tag, int id, const struct switcher__get_methods_description_by_class *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__get_methods_description_by_class), type))
		return soap->error;
	if (soap_out_std__string(soap, "class-name", -1, &a->class_name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__get_methods_description_by_class * SOAP_FMAC4 soap_in_switcher__get_methods_description_by_class(struct soap *soap, const char *tag, struct switcher__get_methods_description_by_class *a, const char *type)
{
	size_t soap_flag_class_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__get_methods_description_by_class *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__get_methods_description_by_class, sizeof(struct switcher__get_methods_description_by_class), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_switcher__get_methods_description_by_class(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_class_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "class-name", &a->class_name, "xsd:string"))
				{	soap_flag_class_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__get_methods_description_by_class *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__get_methods_description_by_class, 0, sizeof(struct switcher__get_methods_description_by_class), 0, soap_copy_switcher__get_methods_description_by_class);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_class_name > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__get_methods_description_by_class(struct soap *soap, const struct switcher__get_methods_description_by_class *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__get_methods_description_by_class);
	if (soap_out_switcher__get_methods_description_by_class(soap, tag?tag:"switcher:get-methods-description-by-class", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__get_methods_description_by_class * SOAP_FMAC4 soap_get_switcher__get_methods_description_by_class(struct soap *soap, struct switcher__get_methods_description_by_class *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__get_methods_description_by_class(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__get_methods_description_by_class * SOAP_FMAC2 soap_instantiate_switcher__get_methods_description_by_class(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__get_methods_description_by_class(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__get_methods_description_by_class, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_methods_description_by_class);
		if (size)
			*size = sizeof(struct switcher__get_methods_description_by_class);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_methods_description_by_class[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__get_methods_description_by_class);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__get_methods_description_by_class*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__get_methods_description_by_class(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__get_methods_description_by_class %p -> %p\n", q, p));
	*(struct switcher__get_methods_description_by_class*)p = *(struct switcher__get_methods_description_by_class*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__get_methods_description_by_classResponse(struct soap *soap, struct switcher__get_methods_description_by_classResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__get_methods_description_by_classResponse(struct soap *soap, const struct switcher__get_methods_description_by_classResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__get_methods_description_by_classResponse(struct soap *soap, const char *tag, int id, const struct switcher__get_methods_description_by_classResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__get_methods_description_by_classResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__get_methods_description_by_classResponse * SOAP_FMAC4 soap_in_switcher__get_methods_description_by_classResponse(struct soap *soap, const char *tag, struct switcher__get_methods_description_by_classResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__get_methods_description_by_classResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__get_methods_description_by_classResponse, sizeof(struct switcher__get_methods_description_by_classResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_switcher__get_methods_description_by_classResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__get_methods_description_by_classResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__get_methods_description_by_classResponse, 0, sizeof(struct switcher__get_methods_description_by_classResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__get_methods_description_by_classResponse(struct soap *soap, const struct switcher__get_methods_description_by_classResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__get_methods_description_by_classResponse);
	if (soap_out_switcher__get_methods_description_by_classResponse(soap, tag?tag:"switcher:get-methods-description-by-classResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__get_methods_description_by_classResponse * SOAP_FMAC4 soap_get_switcher__get_methods_description_by_classResponse(struct soap *soap, struct switcher__get_methods_description_by_classResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__get_methods_description_by_classResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__get_methods_description_by_classResponse * SOAP_FMAC2 soap_instantiate_switcher__get_methods_description_by_classResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__get_methods_description_by_classResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__get_methods_description_by_classResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_methods_description_by_classResponse);
		if (size)
			*size = sizeof(struct switcher__get_methods_description_by_classResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_methods_description_by_classResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__get_methods_description_by_classResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__get_methods_description_by_classResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__get_methods_description_by_classResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__get_methods_description_by_classResponse %p -> %p\n", q, p));
	*(struct switcher__get_methods_description_by_classResponse*)p = *(struct switcher__get_methods_description_by_classResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__get_method_description(struct soap *soap, struct switcher__get_method_description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->quiddity_name);
	soap_default_std__string(soap, &a->method_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__get_method_description(struct soap *soap, const struct switcher__get_method_description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->quiddity_name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->quiddity_name);
	soap_embedded(soap, &a->method_name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->method_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__get_method_description(struct soap *soap, const char *tag, int id, const struct switcher__get_method_description *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__get_method_description), type))
		return soap->error;
	if (soap_out_std__string(soap, "quiddity-name", -1, &a->quiddity_name, ""))
		return soap->error;
	if (soap_out_std__string(soap, "method-name", -1, &a->method_name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__get_method_description * SOAP_FMAC4 soap_in_switcher__get_method_description(struct soap *soap, const char *tag, struct switcher__get_method_description *a, const char *type)
{
	size_t soap_flag_quiddity_name = 1;
	size_t soap_flag_method_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__get_method_description *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__get_method_description, sizeof(struct switcher__get_method_description), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_switcher__get_method_description(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_quiddity_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "quiddity-name", &a->quiddity_name, "xsd:string"))
				{	soap_flag_quiddity_name--;
					continue;
				}
			if (soap_flag_method_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "method-name", &a->method_name, "xsd:string"))
				{	soap_flag_method_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__get_method_description *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__get_method_description, 0, sizeof(struct switcher__get_method_description), 0, soap_copy_switcher__get_method_description);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_quiddity_name > 0 || soap_flag_method_name > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__get_method_description(struct soap *soap, const struct switcher__get_method_description *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__get_method_description);
	if (soap_out_switcher__get_method_description(soap, tag?tag:"switcher:get-method-description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__get_method_description * SOAP_FMAC4 soap_get_switcher__get_method_description(struct soap *soap, struct switcher__get_method_description *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__get_method_description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__get_method_description * SOAP_FMAC2 soap_instantiate_switcher__get_method_description(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__get_method_description(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__get_method_description, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_method_description);
		if (size)
			*size = sizeof(struct switcher__get_method_description);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_method_description[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__get_method_description);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__get_method_description*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__get_method_description(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__get_method_description %p -> %p\n", q, p));
	*(struct switcher__get_method_description*)p = *(struct switcher__get_method_description*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__get_method_descriptionResponse(struct soap *soap, struct switcher__get_method_descriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__get_method_descriptionResponse(struct soap *soap, const struct switcher__get_method_descriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__get_method_descriptionResponse(struct soap *soap, const char *tag, int id, const struct switcher__get_method_descriptionResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__get_method_descriptionResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__get_method_descriptionResponse * SOAP_FMAC4 soap_in_switcher__get_method_descriptionResponse(struct soap *soap, const char *tag, struct switcher__get_method_descriptionResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__get_method_descriptionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__get_method_descriptionResponse, sizeof(struct switcher__get_method_descriptionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_switcher__get_method_descriptionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__get_method_descriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__get_method_descriptionResponse, 0, sizeof(struct switcher__get_method_descriptionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__get_method_descriptionResponse(struct soap *soap, const struct switcher__get_method_descriptionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__get_method_descriptionResponse);
	if (soap_out_switcher__get_method_descriptionResponse(soap, tag?tag:"switcher:get-method-descriptionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__get_method_descriptionResponse * SOAP_FMAC4 soap_get_switcher__get_method_descriptionResponse(struct soap *soap, struct switcher__get_method_descriptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__get_method_descriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__get_method_descriptionResponse * SOAP_FMAC2 soap_instantiate_switcher__get_method_descriptionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__get_method_descriptionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__get_method_descriptionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_method_descriptionResponse);
		if (size)
			*size = sizeof(struct switcher__get_method_descriptionResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_method_descriptionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__get_method_descriptionResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__get_method_descriptionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__get_method_descriptionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__get_method_descriptionResponse %p -> %p\n", q, p));
	*(struct switcher__get_method_descriptionResponse*)p = *(struct switcher__get_method_descriptionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__get_methods_description(struct soap *soap, struct switcher__get_methods_description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->quiddity_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__get_methods_description(struct soap *soap, const struct switcher__get_methods_description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->quiddity_name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->quiddity_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__get_methods_description(struct soap *soap, const char *tag, int id, const struct switcher__get_methods_description *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__get_methods_description), type))
		return soap->error;
	if (soap_out_std__string(soap, "quiddity-name", -1, &a->quiddity_name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__get_methods_description * SOAP_FMAC4 soap_in_switcher__get_methods_description(struct soap *soap, const char *tag, struct switcher__get_methods_description *a, const char *type)
{
	size_t soap_flag_quiddity_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__get_methods_description *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__get_methods_description, sizeof(struct switcher__get_methods_description), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_switcher__get_methods_description(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_quiddity_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "quiddity-name", &a->quiddity_name, "xsd:string"))
				{	soap_flag_quiddity_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__get_methods_description *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__get_methods_description, 0, sizeof(struct switcher__get_methods_description), 0, soap_copy_switcher__get_methods_description);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_quiddity_name > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__get_methods_description(struct soap *soap, const struct switcher__get_methods_description *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__get_methods_description);
	if (soap_out_switcher__get_methods_description(soap, tag?tag:"switcher:get-methods-description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__get_methods_description * SOAP_FMAC4 soap_get_switcher__get_methods_description(struct soap *soap, struct switcher__get_methods_description *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__get_methods_description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__get_methods_description * SOAP_FMAC2 soap_instantiate_switcher__get_methods_description(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__get_methods_description(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__get_methods_description, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_methods_description);
		if (size)
			*size = sizeof(struct switcher__get_methods_description);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_methods_description[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__get_methods_description);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__get_methods_description*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__get_methods_description(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__get_methods_description %p -> %p\n", q, p));
	*(struct switcher__get_methods_description*)p = *(struct switcher__get_methods_description*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__get_methods_descriptionResponse(struct soap *soap, struct switcher__get_methods_descriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__get_methods_descriptionResponse(struct soap *soap, const struct switcher__get_methods_descriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__get_methods_descriptionResponse(struct soap *soap, const char *tag, int id, const struct switcher__get_methods_descriptionResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__get_methods_descriptionResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__get_methods_descriptionResponse * SOAP_FMAC4 soap_in_switcher__get_methods_descriptionResponse(struct soap *soap, const char *tag, struct switcher__get_methods_descriptionResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__get_methods_descriptionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__get_methods_descriptionResponse, sizeof(struct switcher__get_methods_descriptionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_switcher__get_methods_descriptionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__get_methods_descriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__get_methods_descriptionResponse, 0, sizeof(struct switcher__get_methods_descriptionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__get_methods_descriptionResponse(struct soap *soap, const struct switcher__get_methods_descriptionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__get_methods_descriptionResponse);
	if (soap_out_switcher__get_methods_descriptionResponse(soap, tag?tag:"switcher:get-methods-descriptionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__get_methods_descriptionResponse * SOAP_FMAC4 soap_get_switcher__get_methods_descriptionResponse(struct soap *soap, struct switcher__get_methods_descriptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__get_methods_descriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__get_methods_descriptionResponse * SOAP_FMAC2 soap_instantiate_switcher__get_methods_descriptionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__get_methods_descriptionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__get_methods_descriptionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_methods_descriptionResponse);
		if (size)
			*size = sizeof(struct switcher__get_methods_descriptionResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_methods_descriptionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__get_methods_descriptionResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__get_methods_descriptionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__get_methods_descriptionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__get_methods_descriptionResponse %p -> %p\n", q, p));
	*(struct switcher__get_methods_descriptionResponse*)p = *(struct switcher__get_methods_descriptionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__delete_quiddity(struct soap *soap, struct switcher__delete_quiddity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->quiddity_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__delete_quiddity(struct soap *soap, const struct switcher__delete_quiddity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->quiddity_name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->quiddity_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__delete_quiddity(struct soap *soap, const char *tag, int id, const struct switcher__delete_quiddity *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__delete_quiddity), type))
		return soap->error;
	if (soap_out_std__string(soap, "quiddity-name", -1, &a->quiddity_name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__delete_quiddity * SOAP_FMAC4 soap_in_switcher__delete_quiddity(struct soap *soap, const char *tag, struct switcher__delete_quiddity *a, const char *type)
{
	size_t soap_flag_quiddity_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__delete_quiddity *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__delete_quiddity, sizeof(struct switcher__delete_quiddity), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_switcher__delete_quiddity(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_quiddity_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "quiddity-name", &a->quiddity_name, "xsd:string"))
				{	soap_flag_quiddity_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__delete_quiddity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__delete_quiddity, 0, sizeof(struct switcher__delete_quiddity), 0, soap_copy_switcher__delete_quiddity);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_quiddity_name > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__delete_quiddity(struct soap *soap, const struct switcher__delete_quiddity *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__delete_quiddity);
	if (soap_out_switcher__delete_quiddity(soap, tag?tag:"switcher:delete-quiddity", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__delete_quiddity * SOAP_FMAC4 soap_get_switcher__delete_quiddity(struct soap *soap, struct switcher__delete_quiddity *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__delete_quiddity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__delete_quiddity * SOAP_FMAC2 soap_instantiate_switcher__delete_quiddity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__delete_quiddity(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__delete_quiddity, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__delete_quiddity);
		if (size)
			*size = sizeof(struct switcher__delete_quiddity);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__delete_quiddity[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__delete_quiddity);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__delete_quiddity*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__delete_quiddity(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__delete_quiddity %p -> %p\n", q, p));
	*(struct switcher__delete_quiddity*)p = *(struct switcher__delete_quiddity*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__rename_quiddity(struct soap *soap, struct switcher__rename_quiddity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->nick_name);
	soap_default_std__string(soap, &a->new_nick_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__rename_quiddity(struct soap *soap, const struct switcher__rename_quiddity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->nick_name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->nick_name);
	soap_embedded(soap, &a->new_nick_name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->new_nick_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__rename_quiddity(struct soap *soap, const char *tag, int id, const struct switcher__rename_quiddity *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__rename_quiddity), type))
		return soap->error;
	if (soap_out_std__string(soap, "nick-name", -1, &a->nick_name, ""))
		return soap->error;
	if (soap_out_std__string(soap, "new-nick-name", -1, &a->new_nick_name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__rename_quiddity * SOAP_FMAC4 soap_in_switcher__rename_quiddity(struct soap *soap, const char *tag, struct switcher__rename_quiddity *a, const char *type)
{
	size_t soap_flag_nick_name = 1;
	size_t soap_flag_new_nick_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__rename_quiddity *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__rename_quiddity, sizeof(struct switcher__rename_quiddity), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_switcher__rename_quiddity(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nick_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "nick-name", &a->nick_name, "xsd:string"))
				{	soap_flag_nick_name--;
					continue;
				}
			if (soap_flag_new_nick_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "new-nick-name", &a->new_nick_name, "xsd:string"))
				{	soap_flag_new_nick_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__rename_quiddity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__rename_quiddity, 0, sizeof(struct switcher__rename_quiddity), 0, soap_copy_switcher__rename_quiddity);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_nick_name > 0 || soap_flag_new_nick_name > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__rename_quiddity(struct soap *soap, const struct switcher__rename_quiddity *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__rename_quiddity);
	if (soap_out_switcher__rename_quiddity(soap, tag?tag:"switcher:rename-quiddity", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__rename_quiddity * SOAP_FMAC4 soap_get_switcher__rename_quiddity(struct soap *soap, struct switcher__rename_quiddity *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__rename_quiddity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__rename_quiddity * SOAP_FMAC2 soap_instantiate_switcher__rename_quiddity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__rename_quiddity(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__rename_quiddity, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__rename_quiddity);
		if (size)
			*size = sizeof(struct switcher__rename_quiddity);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__rename_quiddity[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__rename_quiddity);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__rename_quiddity*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__rename_quiddity(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__rename_quiddity %p -> %p\n", q, p));
	*(struct switcher__rename_quiddity*)p = *(struct switcher__rename_quiddity*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__rename_quiddityResponse(struct soap *soap, struct switcher__rename_quiddityResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__rename_quiddityResponse(struct soap *soap, const struct switcher__rename_quiddityResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__rename_quiddityResponse(struct soap *soap, const char *tag, int id, const struct switcher__rename_quiddityResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__rename_quiddityResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__rename_quiddityResponse * SOAP_FMAC4 soap_in_switcher__rename_quiddityResponse(struct soap *soap, const char *tag, struct switcher__rename_quiddityResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__rename_quiddityResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__rename_quiddityResponse, sizeof(struct switcher__rename_quiddityResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_switcher__rename_quiddityResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__rename_quiddityResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__rename_quiddityResponse, 0, sizeof(struct switcher__rename_quiddityResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__rename_quiddityResponse(struct soap *soap, const struct switcher__rename_quiddityResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__rename_quiddityResponse);
	if (soap_out_switcher__rename_quiddityResponse(soap, tag?tag:"switcher:rename-quiddityResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__rename_quiddityResponse * SOAP_FMAC4 soap_get_switcher__rename_quiddityResponse(struct soap *soap, struct switcher__rename_quiddityResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__rename_quiddityResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__rename_quiddityResponse * SOAP_FMAC2 soap_instantiate_switcher__rename_quiddityResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__rename_quiddityResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__rename_quiddityResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__rename_quiddityResponse);
		if (size)
			*size = sizeof(struct switcher__rename_quiddityResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__rename_quiddityResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__rename_quiddityResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__rename_quiddityResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__rename_quiddityResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__rename_quiddityResponse %p -> %p\n", q, p));
	*(struct switcher__rename_quiddityResponse*)p = *(struct switcher__rename_quiddityResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__create_named_quiddity(struct soap *soap, struct switcher__create_named_quiddity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->quiddity_class);
	soap_default_std__string(soap, &a->nick_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__create_named_quiddity(struct soap *soap, const struct switcher__create_named_quiddity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->quiddity_class, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->quiddity_class);
	soap_embedded(soap, &a->nick_name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->nick_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__create_named_quiddity(struct soap *soap, const char *tag, int id, const struct switcher__create_named_quiddity *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__create_named_quiddity), type))
		return soap->error;
	if (soap_out_std__string(soap, "quiddity-class", -1, &a->quiddity_class, ""))
		return soap->error;
	if (soap_out_std__string(soap, "nick-name", -1, &a->nick_name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__create_named_quiddity * SOAP_FMAC4 soap_in_switcher__create_named_quiddity(struct soap *soap, const char *tag, struct switcher__create_named_quiddity *a, const char *type)
{
	size_t soap_flag_quiddity_class = 1;
	size_t soap_flag_nick_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__create_named_quiddity *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__create_named_quiddity, sizeof(struct switcher__create_named_quiddity), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_switcher__create_named_quiddity(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_quiddity_class && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "quiddity-class", &a->quiddity_class, "xsd:string"))
				{	soap_flag_quiddity_class--;
					continue;
				}
			if (soap_flag_nick_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "nick-name", &a->nick_name, "xsd:string"))
				{	soap_flag_nick_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__create_named_quiddity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__create_named_quiddity, 0, sizeof(struct switcher__create_named_quiddity), 0, soap_copy_switcher__create_named_quiddity);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_quiddity_class > 0 || soap_flag_nick_name > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__create_named_quiddity(struct soap *soap, const struct switcher__create_named_quiddity *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__create_named_quiddity);
	if (soap_out_switcher__create_named_quiddity(soap, tag?tag:"switcher:create-named-quiddity", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__create_named_quiddity * SOAP_FMAC4 soap_get_switcher__create_named_quiddity(struct soap *soap, struct switcher__create_named_quiddity *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__create_named_quiddity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__create_named_quiddity * SOAP_FMAC2 soap_instantiate_switcher__create_named_quiddity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__create_named_quiddity(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__create_named_quiddity, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__create_named_quiddity);
		if (size)
			*size = sizeof(struct switcher__create_named_quiddity);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__create_named_quiddity[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__create_named_quiddity);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__create_named_quiddity*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__create_named_quiddity(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__create_named_quiddity %p -> %p\n", q, p));
	*(struct switcher__create_named_quiddity*)p = *(struct switcher__create_named_quiddity*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__create_named_quiddityResponse(struct soap *soap, struct switcher__create_named_quiddityResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__create_named_quiddityResponse(struct soap *soap, const struct switcher__create_named_quiddityResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__create_named_quiddityResponse(struct soap *soap, const char *tag, int id, const struct switcher__create_named_quiddityResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__create_named_quiddityResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__create_named_quiddityResponse * SOAP_FMAC4 soap_in_switcher__create_named_quiddityResponse(struct soap *soap, const char *tag, struct switcher__create_named_quiddityResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__create_named_quiddityResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__create_named_quiddityResponse, sizeof(struct switcher__create_named_quiddityResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_switcher__create_named_quiddityResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__create_named_quiddityResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__create_named_quiddityResponse, 0, sizeof(struct switcher__create_named_quiddityResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__create_named_quiddityResponse(struct soap *soap, const struct switcher__create_named_quiddityResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__create_named_quiddityResponse);
	if (soap_out_switcher__create_named_quiddityResponse(soap, tag?tag:"switcher:create-named-quiddityResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__create_named_quiddityResponse * SOAP_FMAC4 soap_get_switcher__create_named_quiddityResponse(struct soap *soap, struct switcher__create_named_quiddityResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__create_named_quiddityResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__create_named_quiddityResponse * SOAP_FMAC2 soap_instantiate_switcher__create_named_quiddityResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__create_named_quiddityResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__create_named_quiddityResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__create_named_quiddityResponse);
		if (size)
			*size = sizeof(struct switcher__create_named_quiddityResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__create_named_quiddityResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__create_named_quiddityResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__create_named_quiddityResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__create_named_quiddityResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__create_named_quiddityResponse %p -> %p\n", q, p));
	*(struct switcher__create_named_quiddityResponse*)p = *(struct switcher__create_named_quiddityResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__create_quiddity(struct soap *soap, struct switcher__create_quiddity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->quiddity_class);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__create_quiddity(struct soap *soap, const struct switcher__create_quiddity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->quiddity_class, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->quiddity_class);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__create_quiddity(struct soap *soap, const char *tag, int id, const struct switcher__create_quiddity *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__create_quiddity), type))
		return soap->error;
	if (soap_out_std__string(soap, "quiddity-class", -1, &a->quiddity_class, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__create_quiddity * SOAP_FMAC4 soap_in_switcher__create_quiddity(struct soap *soap, const char *tag, struct switcher__create_quiddity *a, const char *type)
{
	size_t soap_flag_quiddity_class = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__create_quiddity *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__create_quiddity, sizeof(struct switcher__create_quiddity), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_switcher__create_quiddity(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_quiddity_class && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "quiddity-class", &a->quiddity_class, "xsd:string"))
				{	soap_flag_quiddity_class--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__create_quiddity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__create_quiddity, 0, sizeof(struct switcher__create_quiddity), 0, soap_copy_switcher__create_quiddity);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_quiddity_class > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__create_quiddity(struct soap *soap, const struct switcher__create_quiddity *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__create_quiddity);
	if (soap_out_switcher__create_quiddity(soap, tag?tag:"switcher:create-quiddity", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__create_quiddity * SOAP_FMAC4 soap_get_switcher__create_quiddity(struct soap *soap, struct switcher__create_quiddity *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__create_quiddity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__create_quiddity * SOAP_FMAC2 soap_instantiate_switcher__create_quiddity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__create_quiddity(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__create_quiddity, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__create_quiddity);
		if (size)
			*size = sizeof(struct switcher__create_quiddity);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__create_quiddity[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__create_quiddity);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__create_quiddity*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__create_quiddity(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__create_quiddity %p -> %p\n", q, p));
	*(struct switcher__create_quiddity*)p = *(struct switcher__create_quiddity*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__create_quiddityResponse(struct soap *soap, struct switcher__create_quiddityResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__create_quiddityResponse(struct soap *soap, const struct switcher__create_quiddityResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__create_quiddityResponse(struct soap *soap, const char *tag, int id, const struct switcher__create_quiddityResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__create_quiddityResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__create_quiddityResponse * SOAP_FMAC4 soap_in_switcher__create_quiddityResponse(struct soap *soap, const char *tag, struct switcher__create_quiddityResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__create_quiddityResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__create_quiddityResponse, sizeof(struct switcher__create_quiddityResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_switcher__create_quiddityResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__create_quiddityResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__create_quiddityResponse, 0, sizeof(struct switcher__create_quiddityResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__create_quiddityResponse(struct soap *soap, const struct switcher__create_quiddityResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__create_quiddityResponse);
	if (soap_out_switcher__create_quiddityResponse(soap, tag?tag:"switcher:create-quiddityResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__create_quiddityResponse * SOAP_FMAC4 soap_get_switcher__create_quiddityResponse(struct soap *soap, struct switcher__create_quiddityResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__create_quiddityResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__create_quiddityResponse * SOAP_FMAC2 soap_instantiate_switcher__create_quiddityResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__create_quiddityResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__create_quiddityResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__create_quiddityResponse);
		if (size)
			*size = sizeof(struct switcher__create_quiddityResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__create_quiddityResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__create_quiddityResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__create_quiddityResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__create_quiddityResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__create_quiddityResponse %p -> %p\n", q, p));
	*(struct switcher__create_quiddityResponse*)p = *(struct switcher__create_quiddityResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__get_property(struct soap *soap, struct switcher__get_property *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->quiddity_name);
	soap_default_std__string(soap, &a->property_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__get_property(struct soap *soap, const struct switcher__get_property *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->quiddity_name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->quiddity_name);
	soap_embedded(soap, &a->property_name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->property_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__get_property(struct soap *soap, const char *tag, int id, const struct switcher__get_property *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__get_property), type))
		return soap->error;
	if (soap_out_std__string(soap, "quiddity-name", -1, &a->quiddity_name, ""))
		return soap->error;
	if (soap_out_std__string(soap, "property-name", -1, &a->property_name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__get_property * SOAP_FMAC4 soap_in_switcher__get_property(struct soap *soap, const char *tag, struct switcher__get_property *a, const char *type)
{
	size_t soap_flag_quiddity_name = 1;
	size_t soap_flag_property_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__get_property *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__get_property, sizeof(struct switcher__get_property), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_switcher__get_property(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_quiddity_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "quiddity-name", &a->quiddity_name, "xsd:string"))
				{	soap_flag_quiddity_name--;
					continue;
				}
			if (soap_flag_property_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "property-name", &a->property_name, "xsd:string"))
				{	soap_flag_property_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__get_property *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__get_property, 0, sizeof(struct switcher__get_property), 0, soap_copy_switcher__get_property);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_quiddity_name > 0 || soap_flag_property_name > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__get_property(struct soap *soap, const struct switcher__get_property *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__get_property);
	if (soap_out_switcher__get_property(soap, tag?tag:"switcher:get-property", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__get_property * SOAP_FMAC4 soap_get_switcher__get_property(struct soap *soap, struct switcher__get_property *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__get_property(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__get_property * SOAP_FMAC2 soap_instantiate_switcher__get_property(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__get_property(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__get_property, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_property);
		if (size)
			*size = sizeof(struct switcher__get_property);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_property[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__get_property);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__get_property*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__get_property(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__get_property %p -> %p\n", q, p));
	*(struct switcher__get_property*)p = *(struct switcher__get_property*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__get_propertyResponse(struct soap *soap, struct switcher__get_propertyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__get_propertyResponse(struct soap *soap, const struct switcher__get_propertyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__get_propertyResponse(struct soap *soap, const char *tag, int id, const struct switcher__get_propertyResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__get_propertyResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__get_propertyResponse * SOAP_FMAC4 soap_in_switcher__get_propertyResponse(struct soap *soap, const char *tag, struct switcher__get_propertyResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__get_propertyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__get_propertyResponse, sizeof(struct switcher__get_propertyResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_switcher__get_propertyResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__get_propertyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__get_propertyResponse, 0, sizeof(struct switcher__get_propertyResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__get_propertyResponse(struct soap *soap, const struct switcher__get_propertyResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__get_propertyResponse);
	if (soap_out_switcher__get_propertyResponse(soap, tag?tag:"switcher:get-propertyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__get_propertyResponse * SOAP_FMAC4 soap_get_switcher__get_propertyResponse(struct soap *soap, struct switcher__get_propertyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__get_propertyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__get_propertyResponse * SOAP_FMAC2 soap_instantiate_switcher__get_propertyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__get_propertyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__get_propertyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_propertyResponse);
		if (size)
			*size = sizeof(struct switcher__get_propertyResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_propertyResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__get_propertyResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__get_propertyResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__get_propertyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__get_propertyResponse %p -> %p\n", q, p));
	*(struct switcher__get_propertyResponse*)p = *(struct switcher__get_propertyResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__set_property(struct soap *soap, struct switcher__set_property *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->quiddity_name);
	soap_default_std__string(soap, &a->property_name);
	soap_default_std__string(soap, &a->property_value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__set_property(struct soap *soap, const struct switcher__set_property *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->quiddity_name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->quiddity_name);
	soap_embedded(soap, &a->property_name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->property_name);
	soap_embedded(soap, &a->property_value, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->property_value);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__set_property(struct soap *soap, const char *tag, int id, const struct switcher__set_property *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__set_property), type))
		return soap->error;
	if (soap_out_std__string(soap, "quiddity-name", -1, &a->quiddity_name, ""))
		return soap->error;
	if (soap_out_std__string(soap, "property-name", -1, &a->property_name, ""))
		return soap->error;
	if (soap_out_std__string(soap, "property-value", -1, &a->property_value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__set_property * SOAP_FMAC4 soap_in_switcher__set_property(struct soap *soap, const char *tag, struct switcher__set_property *a, const char *type)
{
	size_t soap_flag_quiddity_name = 1;
	size_t soap_flag_property_name = 1;
	size_t soap_flag_property_value = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__set_property *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__set_property, sizeof(struct switcher__set_property), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_switcher__set_property(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_quiddity_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "quiddity-name", &a->quiddity_name, "xsd:string"))
				{	soap_flag_quiddity_name--;
					continue;
				}
			if (soap_flag_property_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "property-name", &a->property_name, "xsd:string"))
				{	soap_flag_property_name--;
					continue;
				}
			if (soap_flag_property_value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "property-value", &a->property_value, "xsd:string"))
				{	soap_flag_property_value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__set_property *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__set_property, 0, sizeof(struct switcher__set_property), 0, soap_copy_switcher__set_property);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_quiddity_name > 0 || soap_flag_property_name > 0 || soap_flag_property_value > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__set_property(struct soap *soap, const struct switcher__set_property *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__set_property);
	if (soap_out_switcher__set_property(soap, tag?tag:"switcher:set-property", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__set_property * SOAP_FMAC4 soap_get_switcher__set_property(struct soap *soap, struct switcher__set_property *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__set_property(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__set_property * SOAP_FMAC2 soap_instantiate_switcher__set_property(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__set_property(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__set_property, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__set_property);
		if (size)
			*size = sizeof(struct switcher__set_property);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__set_property[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__set_property);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__set_property*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__set_property(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__set_property %p -> %p\n", q, p));
	*(struct switcher__set_property*)p = *(struct switcher__set_property*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__get_property_description_by_class(struct soap *soap, struct switcher__get_property_description_by_class *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->class_name);
	soap_default_std__string(soap, &a->property_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__get_property_description_by_class(struct soap *soap, const struct switcher__get_property_description_by_class *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->class_name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->class_name);
	soap_embedded(soap, &a->property_name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->property_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__get_property_description_by_class(struct soap *soap, const char *tag, int id, const struct switcher__get_property_description_by_class *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__get_property_description_by_class), type))
		return soap->error;
	if (soap_out_std__string(soap, "class-name", -1, &a->class_name, ""))
		return soap->error;
	if (soap_out_std__string(soap, "property-name", -1, &a->property_name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__get_property_description_by_class * SOAP_FMAC4 soap_in_switcher__get_property_description_by_class(struct soap *soap, const char *tag, struct switcher__get_property_description_by_class *a, const char *type)
{
	size_t soap_flag_class_name = 1;
	size_t soap_flag_property_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__get_property_description_by_class *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__get_property_description_by_class, sizeof(struct switcher__get_property_description_by_class), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_switcher__get_property_description_by_class(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_class_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "class-name", &a->class_name, "xsd:string"))
				{	soap_flag_class_name--;
					continue;
				}
			if (soap_flag_property_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "property-name", &a->property_name, "xsd:string"))
				{	soap_flag_property_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__get_property_description_by_class *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__get_property_description_by_class, 0, sizeof(struct switcher__get_property_description_by_class), 0, soap_copy_switcher__get_property_description_by_class);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_class_name > 0 || soap_flag_property_name > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__get_property_description_by_class(struct soap *soap, const struct switcher__get_property_description_by_class *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__get_property_description_by_class);
	if (soap_out_switcher__get_property_description_by_class(soap, tag?tag:"switcher:get-property-description-by-class", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__get_property_description_by_class * SOAP_FMAC4 soap_get_switcher__get_property_description_by_class(struct soap *soap, struct switcher__get_property_description_by_class *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__get_property_description_by_class(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__get_property_description_by_class * SOAP_FMAC2 soap_instantiate_switcher__get_property_description_by_class(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__get_property_description_by_class(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__get_property_description_by_class, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_property_description_by_class);
		if (size)
			*size = sizeof(struct switcher__get_property_description_by_class);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_property_description_by_class[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__get_property_description_by_class);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__get_property_description_by_class*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__get_property_description_by_class(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__get_property_description_by_class %p -> %p\n", q, p));
	*(struct switcher__get_property_description_by_class*)p = *(struct switcher__get_property_description_by_class*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__get_property_description_by_classResponse(struct soap *soap, struct switcher__get_property_description_by_classResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__get_property_description_by_classResponse(struct soap *soap, const struct switcher__get_property_description_by_classResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__get_property_description_by_classResponse(struct soap *soap, const char *tag, int id, const struct switcher__get_property_description_by_classResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__get_property_description_by_classResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__get_property_description_by_classResponse * SOAP_FMAC4 soap_in_switcher__get_property_description_by_classResponse(struct soap *soap, const char *tag, struct switcher__get_property_description_by_classResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__get_property_description_by_classResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__get_property_description_by_classResponse, sizeof(struct switcher__get_property_description_by_classResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_switcher__get_property_description_by_classResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__get_property_description_by_classResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__get_property_description_by_classResponse, 0, sizeof(struct switcher__get_property_description_by_classResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__get_property_description_by_classResponse(struct soap *soap, const struct switcher__get_property_description_by_classResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__get_property_description_by_classResponse);
	if (soap_out_switcher__get_property_description_by_classResponse(soap, tag?tag:"switcher:get-property-description-by-classResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__get_property_description_by_classResponse * SOAP_FMAC4 soap_get_switcher__get_property_description_by_classResponse(struct soap *soap, struct switcher__get_property_description_by_classResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__get_property_description_by_classResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__get_property_description_by_classResponse * SOAP_FMAC2 soap_instantiate_switcher__get_property_description_by_classResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__get_property_description_by_classResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__get_property_description_by_classResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_property_description_by_classResponse);
		if (size)
			*size = sizeof(struct switcher__get_property_description_by_classResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_property_description_by_classResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__get_property_description_by_classResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__get_property_description_by_classResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__get_property_description_by_classResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__get_property_description_by_classResponse %p -> %p\n", q, p));
	*(struct switcher__get_property_description_by_classResponse*)p = *(struct switcher__get_property_description_by_classResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__get_properties_description_by_class(struct soap *soap, struct switcher__get_properties_description_by_class *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->class_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__get_properties_description_by_class(struct soap *soap, const struct switcher__get_properties_description_by_class *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->class_name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->class_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__get_properties_description_by_class(struct soap *soap, const char *tag, int id, const struct switcher__get_properties_description_by_class *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__get_properties_description_by_class), type))
		return soap->error;
	if (soap_out_std__string(soap, "class-name", -1, &a->class_name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__get_properties_description_by_class * SOAP_FMAC4 soap_in_switcher__get_properties_description_by_class(struct soap *soap, const char *tag, struct switcher__get_properties_description_by_class *a, const char *type)
{
	size_t soap_flag_class_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__get_properties_description_by_class *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__get_properties_description_by_class, sizeof(struct switcher__get_properties_description_by_class), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_switcher__get_properties_description_by_class(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_class_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "class-name", &a->class_name, "xsd:string"))
				{	soap_flag_class_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__get_properties_description_by_class *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__get_properties_description_by_class, 0, sizeof(struct switcher__get_properties_description_by_class), 0, soap_copy_switcher__get_properties_description_by_class);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_class_name > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__get_properties_description_by_class(struct soap *soap, const struct switcher__get_properties_description_by_class *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__get_properties_description_by_class);
	if (soap_out_switcher__get_properties_description_by_class(soap, tag?tag:"switcher:get-properties-description-by-class", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__get_properties_description_by_class * SOAP_FMAC4 soap_get_switcher__get_properties_description_by_class(struct soap *soap, struct switcher__get_properties_description_by_class *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__get_properties_description_by_class(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__get_properties_description_by_class * SOAP_FMAC2 soap_instantiate_switcher__get_properties_description_by_class(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__get_properties_description_by_class(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__get_properties_description_by_class, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_properties_description_by_class);
		if (size)
			*size = sizeof(struct switcher__get_properties_description_by_class);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_properties_description_by_class[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__get_properties_description_by_class);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__get_properties_description_by_class*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__get_properties_description_by_class(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__get_properties_description_by_class %p -> %p\n", q, p));
	*(struct switcher__get_properties_description_by_class*)p = *(struct switcher__get_properties_description_by_class*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__get_properties_description_by_classResponse(struct soap *soap, struct switcher__get_properties_description_by_classResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__get_properties_description_by_classResponse(struct soap *soap, const struct switcher__get_properties_description_by_classResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__get_properties_description_by_classResponse(struct soap *soap, const char *tag, int id, const struct switcher__get_properties_description_by_classResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__get_properties_description_by_classResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__get_properties_description_by_classResponse * SOAP_FMAC4 soap_in_switcher__get_properties_description_by_classResponse(struct soap *soap, const char *tag, struct switcher__get_properties_description_by_classResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__get_properties_description_by_classResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__get_properties_description_by_classResponse, sizeof(struct switcher__get_properties_description_by_classResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_switcher__get_properties_description_by_classResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__get_properties_description_by_classResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__get_properties_description_by_classResponse, 0, sizeof(struct switcher__get_properties_description_by_classResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__get_properties_description_by_classResponse(struct soap *soap, const struct switcher__get_properties_description_by_classResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__get_properties_description_by_classResponse);
	if (soap_out_switcher__get_properties_description_by_classResponse(soap, tag?tag:"switcher:get-properties-description-by-classResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__get_properties_description_by_classResponse * SOAP_FMAC4 soap_get_switcher__get_properties_description_by_classResponse(struct soap *soap, struct switcher__get_properties_description_by_classResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__get_properties_description_by_classResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__get_properties_description_by_classResponse * SOAP_FMAC2 soap_instantiate_switcher__get_properties_description_by_classResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__get_properties_description_by_classResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__get_properties_description_by_classResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_properties_description_by_classResponse);
		if (size)
			*size = sizeof(struct switcher__get_properties_description_by_classResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_properties_description_by_classResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__get_properties_description_by_classResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__get_properties_description_by_classResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__get_properties_description_by_classResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__get_properties_description_by_classResponse %p -> %p\n", q, p));
	*(struct switcher__get_properties_description_by_classResponse*)p = *(struct switcher__get_properties_description_by_classResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__get_property_description(struct soap *soap, struct switcher__get_property_description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->quiddity_name);
	soap_default_std__string(soap, &a->property_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__get_property_description(struct soap *soap, const struct switcher__get_property_description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->quiddity_name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->quiddity_name);
	soap_embedded(soap, &a->property_name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->property_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__get_property_description(struct soap *soap, const char *tag, int id, const struct switcher__get_property_description *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__get_property_description), type))
		return soap->error;
	if (soap_out_std__string(soap, "quiddity-name", -1, &a->quiddity_name, ""))
		return soap->error;
	if (soap_out_std__string(soap, "property-name", -1, &a->property_name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__get_property_description * SOAP_FMAC4 soap_in_switcher__get_property_description(struct soap *soap, const char *tag, struct switcher__get_property_description *a, const char *type)
{
	size_t soap_flag_quiddity_name = 1;
	size_t soap_flag_property_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__get_property_description *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__get_property_description, sizeof(struct switcher__get_property_description), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_switcher__get_property_description(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_quiddity_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "quiddity-name", &a->quiddity_name, "xsd:string"))
				{	soap_flag_quiddity_name--;
					continue;
				}
			if (soap_flag_property_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "property-name", &a->property_name, "xsd:string"))
				{	soap_flag_property_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__get_property_description *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__get_property_description, 0, sizeof(struct switcher__get_property_description), 0, soap_copy_switcher__get_property_description);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_quiddity_name > 0 || soap_flag_property_name > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__get_property_description(struct soap *soap, const struct switcher__get_property_description *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__get_property_description);
	if (soap_out_switcher__get_property_description(soap, tag?tag:"switcher:get-property-description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__get_property_description * SOAP_FMAC4 soap_get_switcher__get_property_description(struct soap *soap, struct switcher__get_property_description *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__get_property_description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__get_property_description * SOAP_FMAC2 soap_instantiate_switcher__get_property_description(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__get_property_description(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__get_property_description, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_property_description);
		if (size)
			*size = sizeof(struct switcher__get_property_description);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_property_description[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__get_property_description);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__get_property_description*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__get_property_description(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__get_property_description %p -> %p\n", q, p));
	*(struct switcher__get_property_description*)p = *(struct switcher__get_property_description*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__get_property_descriptionResponse(struct soap *soap, struct switcher__get_property_descriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__get_property_descriptionResponse(struct soap *soap, const struct switcher__get_property_descriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__get_property_descriptionResponse(struct soap *soap, const char *tag, int id, const struct switcher__get_property_descriptionResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__get_property_descriptionResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__get_property_descriptionResponse * SOAP_FMAC4 soap_in_switcher__get_property_descriptionResponse(struct soap *soap, const char *tag, struct switcher__get_property_descriptionResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__get_property_descriptionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__get_property_descriptionResponse, sizeof(struct switcher__get_property_descriptionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_switcher__get_property_descriptionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__get_property_descriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__get_property_descriptionResponse, 0, sizeof(struct switcher__get_property_descriptionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__get_property_descriptionResponse(struct soap *soap, const struct switcher__get_property_descriptionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__get_property_descriptionResponse);
	if (soap_out_switcher__get_property_descriptionResponse(soap, tag?tag:"switcher:get-property-descriptionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__get_property_descriptionResponse * SOAP_FMAC4 soap_get_switcher__get_property_descriptionResponse(struct soap *soap, struct switcher__get_property_descriptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__get_property_descriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__get_property_descriptionResponse * SOAP_FMAC2 soap_instantiate_switcher__get_property_descriptionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__get_property_descriptionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__get_property_descriptionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_property_descriptionResponse);
		if (size)
			*size = sizeof(struct switcher__get_property_descriptionResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_property_descriptionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__get_property_descriptionResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__get_property_descriptionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__get_property_descriptionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__get_property_descriptionResponse %p -> %p\n", q, p));
	*(struct switcher__get_property_descriptionResponse*)p = *(struct switcher__get_property_descriptionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__get_properties_description(struct soap *soap, struct switcher__get_properties_description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->quiddity_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__get_properties_description(struct soap *soap, const struct switcher__get_properties_description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->quiddity_name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->quiddity_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__get_properties_description(struct soap *soap, const char *tag, int id, const struct switcher__get_properties_description *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__get_properties_description), type))
		return soap->error;
	if (soap_out_std__string(soap, "quiddity-name", -1, &a->quiddity_name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__get_properties_description * SOAP_FMAC4 soap_in_switcher__get_properties_description(struct soap *soap, const char *tag, struct switcher__get_properties_description *a, const char *type)
{
	size_t soap_flag_quiddity_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__get_properties_description *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__get_properties_description, sizeof(struct switcher__get_properties_description), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_switcher__get_properties_description(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_quiddity_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "quiddity-name", &a->quiddity_name, "xsd:string"))
				{	soap_flag_quiddity_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__get_properties_description *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__get_properties_description, 0, sizeof(struct switcher__get_properties_description), 0, soap_copy_switcher__get_properties_description);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_quiddity_name > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__get_properties_description(struct soap *soap, const struct switcher__get_properties_description *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__get_properties_description);
	if (soap_out_switcher__get_properties_description(soap, tag?tag:"switcher:get-properties-description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__get_properties_description * SOAP_FMAC4 soap_get_switcher__get_properties_description(struct soap *soap, struct switcher__get_properties_description *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__get_properties_description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__get_properties_description * SOAP_FMAC2 soap_instantiate_switcher__get_properties_description(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__get_properties_description(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__get_properties_description, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_properties_description);
		if (size)
			*size = sizeof(struct switcher__get_properties_description);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_properties_description[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__get_properties_description);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__get_properties_description*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__get_properties_description(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__get_properties_description %p -> %p\n", q, p));
	*(struct switcher__get_properties_description*)p = *(struct switcher__get_properties_description*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__get_properties_descriptionResponse(struct soap *soap, struct switcher__get_properties_descriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__get_properties_descriptionResponse(struct soap *soap, const struct switcher__get_properties_descriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__get_properties_descriptionResponse(struct soap *soap, const char *tag, int id, const struct switcher__get_properties_descriptionResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__get_properties_descriptionResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__get_properties_descriptionResponse * SOAP_FMAC4 soap_in_switcher__get_properties_descriptionResponse(struct soap *soap, const char *tag, struct switcher__get_properties_descriptionResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__get_properties_descriptionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__get_properties_descriptionResponse, sizeof(struct switcher__get_properties_descriptionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_switcher__get_properties_descriptionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__get_properties_descriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__get_properties_descriptionResponse, 0, sizeof(struct switcher__get_properties_descriptionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__get_properties_descriptionResponse(struct soap *soap, const struct switcher__get_properties_descriptionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__get_properties_descriptionResponse);
	if (soap_out_switcher__get_properties_descriptionResponse(soap, tag?tag:"switcher:get-properties-descriptionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__get_properties_descriptionResponse * SOAP_FMAC4 soap_get_switcher__get_properties_descriptionResponse(struct soap *soap, struct switcher__get_properties_descriptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__get_properties_descriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__get_properties_descriptionResponse * SOAP_FMAC2 soap_instantiate_switcher__get_properties_descriptionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__get_properties_descriptionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__get_properties_descriptionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_properties_descriptionResponse);
		if (size)
			*size = sizeof(struct switcher__get_properties_descriptionResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_properties_descriptionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__get_properties_descriptionResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__get_properties_descriptionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__get_properties_descriptionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__get_properties_descriptionResponse %p -> %p\n", q, p));
	*(struct switcher__get_properties_descriptionResponse*)p = *(struct switcher__get_properties_descriptionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__get_quiddity_names(struct soap *soap, struct switcher__get_quiddity_names *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__get_quiddity_names(struct soap *soap, const struct switcher__get_quiddity_names *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__get_quiddity_names(struct soap *soap, const char *tag, int id, const struct switcher__get_quiddity_names *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__get_quiddity_names), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__get_quiddity_names * SOAP_FMAC4 soap_in_switcher__get_quiddity_names(struct soap *soap, const char *tag, struct switcher__get_quiddity_names *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__get_quiddity_names *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__get_quiddity_names, sizeof(struct switcher__get_quiddity_names), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_switcher__get_quiddity_names(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__get_quiddity_names *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__get_quiddity_names, 0, sizeof(struct switcher__get_quiddity_names), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__get_quiddity_names(struct soap *soap, const struct switcher__get_quiddity_names *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__get_quiddity_names);
	if (soap_out_switcher__get_quiddity_names(soap, tag?tag:"switcher:get-quiddity-names", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__get_quiddity_names * SOAP_FMAC4 soap_get_switcher__get_quiddity_names(struct soap *soap, struct switcher__get_quiddity_names *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__get_quiddity_names(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__get_quiddity_names * SOAP_FMAC2 soap_instantiate_switcher__get_quiddity_names(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__get_quiddity_names(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__get_quiddity_names, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_quiddity_names);
		if (size)
			*size = sizeof(struct switcher__get_quiddity_names);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_quiddity_names[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__get_quiddity_names);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__get_quiddity_names*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__get_quiddity_names(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__get_quiddity_names %p -> %p\n", q, p));
	*(struct switcher__get_quiddity_names*)p = *(struct switcher__get_quiddity_names*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__get_quiddity_namesResponse(struct soap *soap, struct switcher__get_quiddity_namesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__get_quiddity_namesResponse(struct soap *soap, const struct switcher__get_quiddity_namesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__vectorTemplateOfstd__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__get_quiddity_namesResponse(struct soap *soap, const char *tag, int id, const struct switcher__get_quiddity_namesResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__get_quiddity_namesResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__vectorTemplateOfstd__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__get_quiddity_namesResponse * SOAP_FMAC4 soap_in_switcher__get_quiddity_namesResponse(struct soap *soap, const char *tag, struct switcher__get_quiddity_namesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__get_quiddity_namesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__get_quiddity_namesResponse, sizeof(struct switcher__get_quiddity_namesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_switcher__get_quiddity_namesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfstd__string(soap, "result", &a->result, "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__get_quiddity_namesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__get_quiddity_namesResponse, 0, sizeof(struct switcher__get_quiddity_namesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__get_quiddity_namesResponse(struct soap *soap, const struct switcher__get_quiddity_namesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__get_quiddity_namesResponse);
	if (soap_out_switcher__get_quiddity_namesResponse(soap, tag?tag:"switcher:get-quiddity-namesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__get_quiddity_namesResponse * SOAP_FMAC4 soap_get_switcher__get_quiddity_namesResponse(struct soap *soap, struct switcher__get_quiddity_namesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__get_quiddity_namesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__get_quiddity_namesResponse * SOAP_FMAC2 soap_instantiate_switcher__get_quiddity_namesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__get_quiddity_namesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__get_quiddity_namesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_quiddity_namesResponse);
		if (size)
			*size = sizeof(struct switcher__get_quiddity_namesResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_quiddity_namesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__get_quiddity_namesResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__get_quiddity_namesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__get_quiddity_namesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__get_quiddity_namesResponse %p -> %p\n", q, p));
	*(struct switcher__get_quiddity_namesResponse*)p = *(struct switcher__get_quiddity_namesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__get_class_doc(struct soap *soap, struct switcher__get_class_doc *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->class_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__get_class_doc(struct soap *soap, const struct switcher__get_class_doc *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->class_name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->class_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__get_class_doc(struct soap *soap, const char *tag, int id, const struct switcher__get_class_doc *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__get_class_doc), type))
		return soap->error;
	if (soap_out_std__string(soap, "class-name", -1, &a->class_name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__get_class_doc * SOAP_FMAC4 soap_in_switcher__get_class_doc(struct soap *soap, const char *tag, struct switcher__get_class_doc *a, const char *type)
{
	size_t soap_flag_class_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__get_class_doc *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__get_class_doc, sizeof(struct switcher__get_class_doc), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_switcher__get_class_doc(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_class_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "class-name", &a->class_name, "xsd:string"))
				{	soap_flag_class_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__get_class_doc *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__get_class_doc, 0, sizeof(struct switcher__get_class_doc), 0, soap_copy_switcher__get_class_doc);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_class_name > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__get_class_doc(struct soap *soap, const struct switcher__get_class_doc *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__get_class_doc);
	if (soap_out_switcher__get_class_doc(soap, tag?tag:"switcher:get-class-doc", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__get_class_doc * SOAP_FMAC4 soap_get_switcher__get_class_doc(struct soap *soap, struct switcher__get_class_doc *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__get_class_doc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__get_class_doc * SOAP_FMAC2 soap_instantiate_switcher__get_class_doc(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__get_class_doc(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__get_class_doc, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_class_doc);
		if (size)
			*size = sizeof(struct switcher__get_class_doc);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_class_doc[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__get_class_doc);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__get_class_doc*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__get_class_doc(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__get_class_doc %p -> %p\n", q, p));
	*(struct switcher__get_class_doc*)p = *(struct switcher__get_class_doc*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__get_class_docResponse(struct soap *soap, struct switcher__get_class_docResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__get_class_docResponse(struct soap *soap, const struct switcher__get_class_docResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__get_class_docResponse(struct soap *soap, const char *tag, int id, const struct switcher__get_class_docResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__get_class_docResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__get_class_docResponse * SOAP_FMAC4 soap_in_switcher__get_class_docResponse(struct soap *soap, const char *tag, struct switcher__get_class_docResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__get_class_docResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__get_class_docResponse, sizeof(struct switcher__get_class_docResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_switcher__get_class_docResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__get_class_docResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__get_class_docResponse, 0, sizeof(struct switcher__get_class_docResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__get_class_docResponse(struct soap *soap, const struct switcher__get_class_docResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__get_class_docResponse);
	if (soap_out_switcher__get_class_docResponse(soap, tag?tag:"switcher:get-class-docResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__get_class_docResponse * SOAP_FMAC4 soap_get_switcher__get_class_docResponse(struct soap *soap, struct switcher__get_class_docResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__get_class_docResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__get_class_docResponse * SOAP_FMAC2 soap_instantiate_switcher__get_class_docResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__get_class_docResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__get_class_docResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_class_docResponse);
		if (size)
			*size = sizeof(struct switcher__get_class_docResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_class_docResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__get_class_docResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__get_class_docResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__get_class_docResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__get_class_docResponse %p -> %p\n", q, p));
	*(struct switcher__get_class_docResponse*)p = *(struct switcher__get_class_docResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__get_quiddities_description(struct soap *soap, struct switcher__get_quiddities_description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__get_quiddities_description(struct soap *soap, const struct switcher__get_quiddities_description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__get_quiddities_description(struct soap *soap, const char *tag, int id, const struct switcher__get_quiddities_description *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__get_quiddities_description), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__get_quiddities_description * SOAP_FMAC4 soap_in_switcher__get_quiddities_description(struct soap *soap, const char *tag, struct switcher__get_quiddities_description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__get_quiddities_description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__get_quiddities_description, sizeof(struct switcher__get_quiddities_description), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_switcher__get_quiddities_description(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__get_quiddities_description *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__get_quiddities_description, 0, sizeof(struct switcher__get_quiddities_description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__get_quiddities_description(struct soap *soap, const struct switcher__get_quiddities_description *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__get_quiddities_description);
	if (soap_out_switcher__get_quiddities_description(soap, tag?tag:"switcher:get-quiddities-description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__get_quiddities_description * SOAP_FMAC4 soap_get_switcher__get_quiddities_description(struct soap *soap, struct switcher__get_quiddities_description *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__get_quiddities_description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__get_quiddities_description * SOAP_FMAC2 soap_instantiate_switcher__get_quiddities_description(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__get_quiddities_description(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__get_quiddities_description, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_quiddities_description);
		if (size)
			*size = sizeof(struct switcher__get_quiddities_description);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_quiddities_description[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__get_quiddities_description);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__get_quiddities_description*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__get_quiddities_description(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__get_quiddities_description %p -> %p\n", q, p));
	*(struct switcher__get_quiddities_description*)p = *(struct switcher__get_quiddities_description*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__get_quiddities_descriptionResponse(struct soap *soap, struct switcher__get_quiddities_descriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__get_quiddities_descriptionResponse(struct soap *soap, const struct switcher__get_quiddities_descriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__get_quiddities_descriptionResponse(struct soap *soap, const char *tag, int id, const struct switcher__get_quiddities_descriptionResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__get_quiddities_descriptionResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__get_quiddities_descriptionResponse * SOAP_FMAC4 soap_in_switcher__get_quiddities_descriptionResponse(struct soap *soap, const char *tag, struct switcher__get_quiddities_descriptionResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__get_quiddities_descriptionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__get_quiddities_descriptionResponse, sizeof(struct switcher__get_quiddities_descriptionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_switcher__get_quiddities_descriptionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__get_quiddities_descriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__get_quiddities_descriptionResponse, 0, sizeof(struct switcher__get_quiddities_descriptionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__get_quiddities_descriptionResponse(struct soap *soap, const struct switcher__get_quiddities_descriptionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__get_quiddities_descriptionResponse);
	if (soap_out_switcher__get_quiddities_descriptionResponse(soap, tag?tag:"switcher:get-quiddities-descriptionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__get_quiddities_descriptionResponse * SOAP_FMAC4 soap_get_switcher__get_quiddities_descriptionResponse(struct soap *soap, struct switcher__get_quiddities_descriptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__get_quiddities_descriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__get_quiddities_descriptionResponse * SOAP_FMAC2 soap_instantiate_switcher__get_quiddities_descriptionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__get_quiddities_descriptionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__get_quiddities_descriptionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_quiddities_descriptionResponse);
		if (size)
			*size = sizeof(struct switcher__get_quiddities_descriptionResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_quiddities_descriptionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__get_quiddities_descriptionResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__get_quiddities_descriptionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__get_quiddities_descriptionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__get_quiddities_descriptionResponse %p -> %p\n", q, p));
	*(struct switcher__get_quiddities_descriptionResponse*)p = *(struct switcher__get_quiddities_descriptionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__get_quiddity_description(struct soap *soap, struct switcher__get_quiddity_description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->quiddity_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__get_quiddity_description(struct soap *soap, const struct switcher__get_quiddity_description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->quiddity_name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->quiddity_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__get_quiddity_description(struct soap *soap, const char *tag, int id, const struct switcher__get_quiddity_description *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__get_quiddity_description), type))
		return soap->error;
	if (soap_out_std__string(soap, "quiddity-name", -1, &a->quiddity_name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__get_quiddity_description * SOAP_FMAC4 soap_in_switcher__get_quiddity_description(struct soap *soap, const char *tag, struct switcher__get_quiddity_description *a, const char *type)
{
	size_t soap_flag_quiddity_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__get_quiddity_description *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__get_quiddity_description, sizeof(struct switcher__get_quiddity_description), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_switcher__get_quiddity_description(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_quiddity_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "quiddity-name", &a->quiddity_name, "xsd:string"))
				{	soap_flag_quiddity_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__get_quiddity_description *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__get_quiddity_description, 0, sizeof(struct switcher__get_quiddity_description), 0, soap_copy_switcher__get_quiddity_description);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_quiddity_name > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__get_quiddity_description(struct soap *soap, const struct switcher__get_quiddity_description *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__get_quiddity_description);
	if (soap_out_switcher__get_quiddity_description(soap, tag?tag:"switcher:get-quiddity-description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__get_quiddity_description * SOAP_FMAC4 soap_get_switcher__get_quiddity_description(struct soap *soap, struct switcher__get_quiddity_description *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__get_quiddity_description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__get_quiddity_description * SOAP_FMAC2 soap_instantiate_switcher__get_quiddity_description(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__get_quiddity_description(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__get_quiddity_description, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_quiddity_description);
		if (size)
			*size = sizeof(struct switcher__get_quiddity_description);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_quiddity_description[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__get_quiddity_description);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__get_quiddity_description*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__get_quiddity_description(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__get_quiddity_description %p -> %p\n", q, p));
	*(struct switcher__get_quiddity_description*)p = *(struct switcher__get_quiddity_description*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__get_quiddity_descriptionResponse(struct soap *soap, struct switcher__get_quiddity_descriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__get_quiddity_descriptionResponse(struct soap *soap, const struct switcher__get_quiddity_descriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__get_quiddity_descriptionResponse(struct soap *soap, const char *tag, int id, const struct switcher__get_quiddity_descriptionResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__get_quiddity_descriptionResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__get_quiddity_descriptionResponse * SOAP_FMAC4 soap_in_switcher__get_quiddity_descriptionResponse(struct soap *soap, const char *tag, struct switcher__get_quiddity_descriptionResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__get_quiddity_descriptionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__get_quiddity_descriptionResponse, sizeof(struct switcher__get_quiddity_descriptionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_switcher__get_quiddity_descriptionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__get_quiddity_descriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__get_quiddity_descriptionResponse, 0, sizeof(struct switcher__get_quiddity_descriptionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__get_quiddity_descriptionResponse(struct soap *soap, const struct switcher__get_quiddity_descriptionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__get_quiddity_descriptionResponse);
	if (soap_out_switcher__get_quiddity_descriptionResponse(soap, tag?tag:"switcher:get-quiddity-descriptionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__get_quiddity_descriptionResponse * SOAP_FMAC4 soap_get_switcher__get_quiddity_descriptionResponse(struct soap *soap, struct switcher__get_quiddity_descriptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__get_quiddity_descriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__get_quiddity_descriptionResponse * SOAP_FMAC2 soap_instantiate_switcher__get_quiddity_descriptionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__get_quiddity_descriptionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__get_quiddity_descriptionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_quiddity_descriptionResponse);
		if (size)
			*size = sizeof(struct switcher__get_quiddity_descriptionResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_quiddity_descriptionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__get_quiddity_descriptionResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__get_quiddity_descriptionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__get_quiddity_descriptionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__get_quiddity_descriptionResponse %p -> %p\n", q, p));
	*(struct switcher__get_quiddity_descriptionResponse*)p = *(struct switcher__get_quiddity_descriptionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__get_classes_doc(struct soap *soap, struct switcher__get_classes_doc *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__get_classes_doc(struct soap *soap, const struct switcher__get_classes_doc *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__get_classes_doc(struct soap *soap, const char *tag, int id, const struct switcher__get_classes_doc *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__get_classes_doc), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__get_classes_doc * SOAP_FMAC4 soap_in_switcher__get_classes_doc(struct soap *soap, const char *tag, struct switcher__get_classes_doc *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__get_classes_doc *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__get_classes_doc, sizeof(struct switcher__get_classes_doc), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_switcher__get_classes_doc(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__get_classes_doc *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__get_classes_doc, 0, sizeof(struct switcher__get_classes_doc), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__get_classes_doc(struct soap *soap, const struct switcher__get_classes_doc *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__get_classes_doc);
	if (soap_out_switcher__get_classes_doc(soap, tag?tag:"switcher:get-classes-doc", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__get_classes_doc * SOAP_FMAC4 soap_get_switcher__get_classes_doc(struct soap *soap, struct switcher__get_classes_doc *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__get_classes_doc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__get_classes_doc * SOAP_FMAC2 soap_instantiate_switcher__get_classes_doc(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__get_classes_doc(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__get_classes_doc, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_classes_doc);
		if (size)
			*size = sizeof(struct switcher__get_classes_doc);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_classes_doc[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__get_classes_doc);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__get_classes_doc*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__get_classes_doc(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__get_classes_doc %p -> %p\n", q, p));
	*(struct switcher__get_classes_doc*)p = *(struct switcher__get_classes_doc*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__get_classes_docResponse(struct soap *soap, struct switcher__get_classes_docResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__get_classes_docResponse(struct soap *soap, const struct switcher__get_classes_docResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__get_classes_docResponse(struct soap *soap, const char *tag, int id, const struct switcher__get_classes_docResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__get_classes_docResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__get_classes_docResponse * SOAP_FMAC4 soap_in_switcher__get_classes_docResponse(struct soap *soap, const char *tag, struct switcher__get_classes_docResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__get_classes_docResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__get_classes_docResponse, sizeof(struct switcher__get_classes_docResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_switcher__get_classes_docResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__get_classes_docResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__get_classes_docResponse, 0, sizeof(struct switcher__get_classes_docResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__get_classes_docResponse(struct soap *soap, const struct switcher__get_classes_docResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__get_classes_docResponse);
	if (soap_out_switcher__get_classes_docResponse(soap, tag?tag:"switcher:get-classes-docResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__get_classes_docResponse * SOAP_FMAC4 soap_get_switcher__get_classes_docResponse(struct soap *soap, struct switcher__get_classes_docResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__get_classes_docResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__get_classes_docResponse * SOAP_FMAC2 soap_instantiate_switcher__get_classes_docResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__get_classes_docResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__get_classes_docResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_classes_docResponse);
		if (size)
			*size = sizeof(struct switcher__get_classes_docResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_classes_docResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__get_classes_docResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__get_classes_docResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__get_classes_docResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__get_classes_docResponse %p -> %p\n", q, p));
	*(struct switcher__get_classes_docResponse*)p = *(struct switcher__get_classes_docResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__get_factory_capabilities(struct soap *soap, struct switcher__get_factory_capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__get_factory_capabilities(struct soap *soap, const struct switcher__get_factory_capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__get_factory_capabilities(struct soap *soap, const char *tag, int id, const struct switcher__get_factory_capabilities *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__get_factory_capabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__get_factory_capabilities * SOAP_FMAC4 soap_in_switcher__get_factory_capabilities(struct soap *soap, const char *tag, struct switcher__get_factory_capabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__get_factory_capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__get_factory_capabilities, sizeof(struct switcher__get_factory_capabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_switcher__get_factory_capabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__get_factory_capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__get_factory_capabilities, 0, sizeof(struct switcher__get_factory_capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__get_factory_capabilities(struct soap *soap, const struct switcher__get_factory_capabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__get_factory_capabilities);
	if (soap_out_switcher__get_factory_capabilities(soap, tag?tag:"switcher:get-factory-capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__get_factory_capabilities * SOAP_FMAC4 soap_get_switcher__get_factory_capabilities(struct soap *soap, struct switcher__get_factory_capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__get_factory_capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__get_factory_capabilities * SOAP_FMAC2 soap_instantiate_switcher__get_factory_capabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__get_factory_capabilities(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__get_factory_capabilities, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_factory_capabilities);
		if (size)
			*size = sizeof(struct switcher__get_factory_capabilities);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_factory_capabilities[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__get_factory_capabilities);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__get_factory_capabilities*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__get_factory_capabilities(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__get_factory_capabilities %p -> %p\n", q, p));
	*(struct switcher__get_factory_capabilities*)p = *(struct switcher__get_factory_capabilities*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_switcher__get_factory_capabilitiesResponse(struct soap *soap, struct switcher__get_factory_capabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_switcher__get_factory_capabilitiesResponse(struct soap *soap, const struct switcher__get_factory_capabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__vectorTemplateOfstd__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_switcher__get_factory_capabilitiesResponse(struct soap *soap, const char *tag, int id, const struct switcher__get_factory_capabilitiesResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_switcher__get_factory_capabilitiesResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__vectorTemplateOfstd__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct switcher__get_factory_capabilitiesResponse * SOAP_FMAC4 soap_in_switcher__get_factory_capabilitiesResponse(struct soap *soap, const char *tag, struct switcher__get_factory_capabilitiesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct switcher__get_factory_capabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_switcher__get_factory_capabilitiesResponse, sizeof(struct switcher__get_factory_capabilitiesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_switcher__get_factory_capabilitiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfstd__string(soap, "result", &a->result, "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct switcher__get_factory_capabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_switcher__get_factory_capabilitiesResponse, 0, sizeof(struct switcher__get_factory_capabilitiesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_switcher__get_factory_capabilitiesResponse(struct soap *soap, const struct switcher__get_factory_capabilitiesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_switcher__get_factory_capabilitiesResponse);
	if (soap_out_switcher__get_factory_capabilitiesResponse(soap, tag?tag:"switcher:get-factory-capabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct switcher__get_factory_capabilitiesResponse * SOAP_FMAC4 soap_get_switcher__get_factory_capabilitiesResponse(struct soap *soap, struct switcher__get_factory_capabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_switcher__get_factory_capabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct switcher__get_factory_capabilitiesResponse * SOAP_FMAC2 soap_instantiate_switcher__get_factory_capabilitiesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_switcher__get_factory_capabilitiesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_switcher__get_factory_capabilitiesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_factory_capabilitiesResponse);
		if (size)
			*size = sizeof(struct switcher__get_factory_capabilitiesResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct switcher__get_factory_capabilitiesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct switcher__get_factory_capabilitiesResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct switcher__get_factory_capabilitiesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_switcher__get_factory_capabilitiesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct switcher__get_factory_capabilitiesResponse %p -> %p\n", q, p));
	*(struct switcher__get_factory_capabilitiesResponse*)p = *(struct switcher__get_factory_capabilitiesResponse*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfstd__string))
		soap_serialize_std__vectorTemplateOfstd__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, std::vector<std::string >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOfstd__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<std::string >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = (std::vector<std::string >**)soap_malloc(soap, sizeof(std::vector<std::string >*))))
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfstd__string(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfstd__string);
	if (soap_out_PointerTostd__vectorTemplateOfstd__string(soap, tag?tag:"", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<std::string >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfstd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__QName
	*a = SOAP_DEFAULT__QName;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE__QName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap, -1)))
		return NULL;
	std::string n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		soap_default_std__string(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{
			if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >);
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfstd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
